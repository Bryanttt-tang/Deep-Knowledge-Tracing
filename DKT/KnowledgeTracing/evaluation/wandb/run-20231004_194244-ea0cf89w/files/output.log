Dataset: LON_course4, Learning Rate: 0.002
epoch: 0
loading train data:    : 700it [00:01, 498.90it/s]
loading test data:    : 160it [00:00, 1428.54it/s]
Training:    :   0%|          | 0/110 [00:00<?, ?it/s]..\evaluation\eval.py:31: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]


































Training:    : 100%|██████████| 110/110 [01:26<00:00,  1.27it/s]
Testing:    :   0%|          | 0/26 [00:00<?, ?it/s]..\evaluation\eval.py:73: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]




Testing:    :  77%|███████▋  | 20/26 [00:12<00:03,  1.65it/s]
auc:0.682201135843209 f1: 0.44313328343093655 recall: 0.3571707420946162 precision: 0.5835894462162946
Testing:    : 100%|██████████| 26/26 [00:15<00:00,  1.68it/s]
Training:    :   0%|          | 0/110 [00:00<?, ?it/s]..\evaluation\eval.py:31: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]


































Training:    : 100%|██████████| 110/110 [01:26<00:00,  1.27it/s]
Testing:    :   0%|          | 0/26 [00:00<?, ?it/s]..\evaluation\eval.py:73: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]





Testing:    : 100%|██████████| 26/26 [00:15<00:00,  1.70it/s]
Training:    :   0%|          | 0/110 [00:00<?, ?it/s]..\evaluation\eval.py:31: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]
auc:0.6868172146598566 f1: 0.436985747043748 recall: 0.34492671327678603 precision: 0.5960748236737197
epoch: 2



































Training:    : 100%|██████████| 110/110 [01:25<00:00,  1.28it/s]
Testing:    :   0%|          | 0/26 [00:00<?, ?it/s]..\evaluation\eval.py:73: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]





Testing:    : 100%|██████████| 26/26 [00:16<00:00,  1.54it/s]
Training:    :   0%|          | 0/110 [00:00<?, ?it/s]..\evaluation\eval.py:31: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]
auc:0.6897244688148916 f1: 0.4490438794977595 recall: 0.35919366859495333 precision: 0.5988403053073783
epoch: 3



































Training:    : 100%|██████████| 110/110 [01:27<00:00,  1.25it/s]
Testing:    :   0%|          | 0/26 [00:00<?, ?it/s]..\evaluation\eval.py:73: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]





Testing:    :  88%|████████▊ | 23/26 [00:15<00:02,  1.47it/s]
auc:0.6917070058443001 f1: 0.4427301845085036 recall: 0.3482982574440146 precision: 0.6074147428359226
Testing:    : 100%|██████████| 26/26 [00:17<00:00,  1.50it/s]
Training:    :   0%|          | 0/110 [00:00<?, ?it/s]..\evaluation\eval.py:31: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]


































Training:    : 100%|██████████| 110/110 [01:31<00:00,  1.21it/s]
Testing:    :   0%|          | 0/26 [00:00<?, ?it/s]..\evaluation\eval.py:73: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]




Testing:    :  77%|███████▋  | 20/26 [00:13<00:04,  1.50it/s]
Testing:    : 100%|██████████| 26/26 [00:16<00:00,  1.56it/s]
Training:    :   0%|          | 0/110 [00:00<?, ?it/s]..\evaluation\eval.py:31: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]
epoch: 5


































Training:    : 100%|██████████| 110/110 [01:30<00:00,  1.22it/s]
Testing:    :   0%|          | 0/26 [00:00<?, ?it/s]..\evaluation\eval.py:73: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]





Testing:    :  88%|████████▊ | 23/26 [00:15<00:01,  1.51it/s]
auc:0.696030168787151 f1: 0.4519280090992217 recall: 0.3595840579195798 precision: 0.6080902652742768
Testing:    : 100%|██████████| 26/26 [00:16<00:00,  1.53it/s]
Training:    :   0%|          | 0/110 [00:00<?, ?it/s]..\evaluation\eval.py:31: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]




































Training:    : 100%|██████████| 110/110 [01:40<00:00,  1.09it/s]
Testing:    :   0%|          | 0/26 [00:00<?, ?it/s]..\evaluation\eval.py:73: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]






Testing:    :  85%|████████▍ | 22/26 [00:17<00:02,  1.37it/s]
auc:0.6981032741069649 f1: 0.45675326411478984 recall: 0.3637718706746637 precision: 0.6135887458844658
Testing:    : 100%|██████████| 26/26 [00:19<00:00,  1.35it/s]
Training:    :   0%|          | 0/110 [00:00<?, ?it/s]..\evaluation\eval.py:31: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]


































Training:    : 100%|██████████| 110/110 [01:31<00:00,  1.20it/s]
Testing:    :   0%|          | 0/26 [00:00<?, ?it/s]..\evaluation\eval.py:73: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]




Testing:    :  77%|███████▋  | 20/26 [00:12<00:03,  1.67it/s]
auc:0.6996031696457669 f1: 0.4608794086964242 recall: 0.36845654257018134 precision: 0.6151931737378525
Testing:    : 100%|██████████| 26/26 [00:15<00:00,  1.70it/s]
Training:    :   0%|          | 0/110 [00:00<?, ?it/s]..\evaluation\eval.py:31: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]



































Training:    : 100%|██████████| 110/110 [01:25<00:00,  1.28it/s]
Testing:    :   0%|          | 0/26 [00:00<?, ?it/s]..\evaluation\eval.py:73: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]





Testing:    :  92%|█████████▏| 24/26 [00:15<00:01,  1.56it/s]
auc:0.7006864180886891 f1: 0.4621460903523565 recall: 0.3695922206054584 precision: 0.6165413533834586
Testing:    : 100%|██████████| 26/26 [00:16<00:00,  1.62it/s]
Training:    :   0%|          | 0/110 [00:00<?, ?it/s]..\evaluation\eval.py:31: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]


































Training:    : 100%|██████████| 110/110 [01:27<00:00,  1.26it/s]
Testing:    :   0%|          | 0/26 [00:00<?, ?it/s]..\evaluation\eval.py:73: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]




Testing:    : 100%|██████████| 26/26 [00:15<00:00,  1.65it/s]
Training:    :   0%|          | 0/110 [00:00<?, ?it/s]..\evaluation\eval.py:31: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]
auc:0.7011877118832389 f1: 0.4614804295730896 recall: 0.3690598715264223 precision: 0.6156533064945829
epoch: 10


































Training:    : 100%|██████████| 110/110 [01:30<00:00,  1.21it/s]
Testing:    :   0%|          | 0/26 [00:00<?, ?it/s]..\evaluation\eval.py:73: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]




Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.67it/s]
auc:0.7028512183932846 f1: 0.4755560377563198 recall: 0.3888987472051673 precision: 0.6119052937234756
Testing:    : 100%|██████████| 26/26 [00:15<00:00,  1.70it/s]
Training:    :   0%|          | 0/110 [00:00<?, ?it/s]..\evaluation\eval.py:31: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]



































Training:    : 100%|██████████| 110/110 [01:25<00:00,  1.28it/s]
Testing:    :   0%|          | 0/26 [00:00<?, ?it/s]..\evaluation\eval.py:73: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]




Testing:    : 100%|██████████| 26/26 [00:14<00:00,  1.74it/s]
Training:    :   0%|          | 0/110 [00:00<?, ?it/s]..\evaluation\eval.py:31: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]
auc:0.7031993105273177 f1: 0.4689821938887667 recall: 0.3785711750718671 precision: 0.6161266100618032
epoch: 12


































Training:    : 100%|██████████| 110/110 [01:22<00:00,  1.34it/s]
Testing:    :   0%|          | 0/26 [00:00<?, ?it/s]..\evaluation\eval.py:73: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]





Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.69it/s]
auc:0.7044900067608764 f1: 0.4769861765152666 recall: 0.39003442524044435 precision: 0.6138293118856122
Testing:    : 100%|██████████| 26/26 [00:15<00:00,  1.72it/s]
Training:    :   0%|          | 0/110 [00:00<?, ?it/s]..\evaluation\eval.py:31: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]





















Training:    : 100%|██████████| 110/110 [01:28<00:00,  1.25it/s]
Testing:    :   0%|          | 0/26 [00:00<?, ?it/s]..\evaluation\eval.py:73: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]








Testing:    :  92%|█████████▏| 24/26 [6:04:37<24:38, 739.25s/it]
auc:0.704710041764337 f1: 0.47343964746176836 recall: 0.38510132377470985 precision: 0.6143698335409353
Testing:    : 100%|██████████| 26/26 [6:04:38<00:00, 841.48s/it]
Training:    :   0%|          | 0/110 [00:00<?, ?it/s]..\evaluation\eval.py:31: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]







































Training:    : 100%|██████████| 110/110 [01:46<00:00,  1.03it/s]
Testing:    :   0%|          | 0/26 [00:00<?, ?it/s]..\evaluation\eval.py:73: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]






Testing:    :  85%|████████▍ | 22/26 [00:16<00:02,  1.40it/s]
auc:0.705072700580551 f1: 0.484051327092393 recall: 0.40096532632998544 precision: 0.6105706874189365
Testing:    : 100%|██████████| 26/26 [00:18<00:00,  1.39it/s]
Training:    :   0%|          | 0/110 [00:00<?, ?it/s]..\evaluation\eval.py:31: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]


































Training:    : 100%|██████████| 110/110 [01:28<00:00,  1.25it/s]
Testing:    :   0%|          | 0/26 [00:00<?, ?it/s]..\evaluation\eval.py:73: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]




Testing:    :  77%|███████▋  | 20/26 [00:12<00:03,  1.61it/s]
auc:0.7061754765241754 f1: 0.4764890282131662 recall: 0.38840188806473364 precision: 0.6162509150289994
Testing:    : 100%|██████████| 26/26 [00:16<00:00,  1.61it/s]
Training:    :   0%|          | 0/110 [00:00<?, ?it/s]..\evaluation\eval.py:31: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]
Training:    :   5%|▌         | 6/110 [00:04<01:20,  1.30it/s]
Training:    :   8%|▊         | 9/110 [00:07<01:19,  1.28it/s]
Training:    :  11%|█         | 12/110 [00:09<01:17,  1.27it/s]
Training:    :  14%|█▎        | 15/110 [00:11<01:17,  1.23it/s]
Training:    :  16%|█▋        | 18/110 [00:14<01:14,  1.23it/s]
Training:    :  19%|█▉        | 21/110 [00:16<01:12,  1.22it/s]
Training:    :  22%|██▏       | 24/110 [00:19<01:10,  1.23it/s]
Training:    :  25%|██▍       | 27/110 [00:21<01:06,  1.25it/s]
Training:    :  27%|██▋       | 30/110 [00:23<01:02,  1.27it/s]
Training:    :  30%|███       | 33/110 [00:26<01:00,  1.27it/s]
Training:    :  33%|███▎      | 36/110 [00:28<00:57,  1.29it/s]
Training:    :  35%|███▌      | 39/110 [00:30<00:55,  1.29it/s]
Training:    :  38%|███▊      | 42/110 [00:33<00:52,  1.30it/s]
Training:    :  41%|████      | 45/110 [00:35<00:49,  1.31it/s]
Training:    :  44%|████▎     | 48/110 [00:37<00:48,  1.29it/s]
Training:    :  46%|████▋     | 51/110 [00:40<00:45,  1.29it/s]
Training:    :  49%|████▉     | 54/110 [00:42<00:43,  1.30it/s]
Training:    :  52%|█████▏    | 57/110 [00:44<00:41,  1.27it/s]
Training:    :  55%|█████▍    | 60/110 [00:47<00:38,  1.29it/s]
Training:    :  57%|█████▋    | 63/110 [00:49<00:37,  1.25it/s]
Training:    :  60%|██████    | 66/110 [00:52<00:36,  1.21it/s]
Training:    :  63%|██████▎   | 69/110 [00:55<00:35,  1.16it/s]
Training:    :  65%|██████▌   | 72/110 [00:57<00:32,  1.16it/s]
Training:    :  68%|██████▊   | 75/110 [01:00<00:29,  1.19it/s]
Training:    :  71%|███████   | 78/110 [01:02<00:27,  1.15it/s]
Training:    :  74%|███████▎  | 81/110 [01:05<00:25,  1.15it/s]
Training:    :  76%|███████▋  | 84/110 [01:08<00:22,  1.16it/s]
Training:    :  79%|███████▉  | 87/110 [01:10<00:20,  1.14it/s]
Training:    :  82%|████████▏ | 90/110 [01:13<00:17,  1.17it/s]
Training:    :  85%|████████▍ | 93/110 [01:15<00:13,  1.22it/s]
Training:    :  87%|████████▋ | 96/110 [01:17<00:11,  1.24it/s]
Training:    :  90%|█████████ | 99/110 [01:20<00:08,  1.26it/s]
Training:    :  93%|█████████▎| 102/110 [01:22<00:06,  1.22it/s]
Training:    :  95%|█████████▌| 105/110 [01:25<00:04,  1.18it/s]
Training:    :  98%|█████████▊| 108/110 [01:27<00:01,  1.20it/s]
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :  15%|█▌        | 4/26 [00:02<00:15,  1.46it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :  27%|██▋       | 7/26 [00:04<00:13,  1.45it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :  38%|███▊      | 10/26 [00:06<00:10,  1.46it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :  54%|█████▍    | 14/26 [00:09<00:07,  1.52it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :  69%|██████▉   | 18/26 [00:11<00:05,  1.56it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :  85%|████████▍ | 22/26 [00:14<00:02,  1.58it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :  85%|████████▍ | 22/26 [00:14<00:02,  1.58it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
auc:0.7059678433801693 f1: 0.47311262918199337 recall: 0.38343329666039677 precision: 0.6175478708202343
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:23,  1.28it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:23,  1.24it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:07<01:20,  1.25it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:09<01:17,  1.27it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:15,  1.26it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:14<01:13,  1.25it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:16<01:11,  1.25it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:19<01:08,  1.26it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:21<01:06,  1.25it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:23<01:03,  1.25it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:26<01:00,  1.27it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:28<00:58,  1.27it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:30<00:55,  1.27it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:33<00:53,  1.27it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:35<00:51,  1.26it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:37<00:48,  1.28it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:40<00:46,  1.27it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:43<00:45,  1.22it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:45<00:44,  1.19it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:48<00:42,  1.19it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:50<00:38,  1.22it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:52<00:35,  1.23it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:55<00:33,  1.23it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:57<00:30,  1.24it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [01:00<00:28,  1.24it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [01:02<00:26,  1.23it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:05<00:23,  1.21it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:07<00:21,  1.21it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:10<00:18,  1.23it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:12<00:15,  1.26it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:14<00:13,  1.23it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:17<00:11,  1.23it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:19<00:08,  1.24it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:22<00:06,  1.26it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:24<00:04,  1.23it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  98%|█████████▊| 108/110 [01:27<00:01,  1.21it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  12%|█▏        | 3/26 [00:02<00:16,  1.36it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  23%|██▎       | 6/26 [00:04<00:14,  1.37it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  35%|███▍      | 9/26 [00:06<00:12,  1.39it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:08<00:09,  1.40it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  58%|█████▊    | 15/26 [00:10<00:07,  1.40it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  69%|██████▉   | 18/26 [00:12<00:05,  1.43it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  81%|████████  | 21/26 [00:14<00:03,  1.41it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:17<00:01,  1.41it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:17<00:01,  1.41it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7061383658646747 f1: 0.47713199348180335 recall: 0.3896795258544203 precision: 0.6151949798296728
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:45,  1.01it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:06<01:47,  1.04s/it]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   7%|▋         | 8/110 [00:08<01:48,  1.06s/it]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   9%|▉         | 10/110 [00:10<01:47,  1.08s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:12<01:44,  1.07s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  13%|█▎        | 14/110 [00:14<01:42,  1.07s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  15%|█▍        | 16/110 [00:17<01:42,  1.09s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:19<01:42,  1.11s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  18%|█▊        | 20/110 [00:21<01:39,  1.10s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  20%|██        | 22/110 [00:23<01:38,  1.12s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:26<01:36,  1.12s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  24%|██▎       | 26/110 [00:28<01:39,  1.19s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▌       | 28/110 [00:31<01:35,  1.16s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:33<01:30,  1.13s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  29%|██▉       | 32/110 [00:35<01:25,  1.10s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  31%|███       | 34/110 [00:37<01:22,  1.09s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:39<01:19,  1.08s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▍      | 38/110 [00:41<01:17,  1.07s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  36%|███▋      | 40/110 [00:43<01:14,  1.06s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:45<01:12,  1.07s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  40%|████      | 44/110 [00:47<01:10,  1.06s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  42%|████▏     | 46/110 [00:49<01:07,  1.06s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:52<01:05,  1.06s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  45%|████▌     | 50/110 [00:54<01:04,  1.08s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  48%|████▊     | 53/110 [00:57<00:58,  1.03s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  51%|█████     | 56/110 [00:59<00:53,  1.02it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  54%|█████▎    | 59/110 [01:03<00:51,  1.02s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▌    | 61/110 [01:05<00:50,  1.02s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [01:07<00:48,  1.03s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  59%|█████▉    | 65/110 [01:09<00:46,  1.04s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  61%|██████    | 67/110 [01:11<00:44,  1.03s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  64%|██████▎   | 70/110 [01:14<00:40,  1.02s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [01:16<00:38,  1.02s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  67%|██████▋   | 74/110 [01:18<00:36,  1.03s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  69%|██████▉   | 76/110 [01:20<00:35,  1.06s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [01:23<00:35,  1.12s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  73%|███████▎  | 80/110 [01:26<00:34,  1.16s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  75%|███████▍  | 82/110 [01:28<00:31,  1.14s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:30<00:29,  1.13s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  78%|███████▊  | 86/110 [01:32<00:26,  1.11s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  81%|████████  | 89/110 [01:35<00:21,  1.04s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  84%|████████▎ | 92/110 [01:38<00:18,  1.00s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▌ | 94/110 [01:40<00:16,  1.02s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  88%|████████▊ | 97/110 [01:43<00:12,  1.01it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  91%|█████████ | 100/110 [01:45<00:09,  1.04it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  94%|█████████▎| 103/110 [01:48<00:06,  1.07it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  96%|█████████▋| 106/110 [01:51<00:03,  1.08it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  99%|█████████▉| 109/110 [01:53<00:00,  1.09it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  12%|█▏        | 3/26 [00:02<00:17,  1.34it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  23%|██▎       | 6/26 [00:04<00:15,  1.32it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  35%|███▍      | 9/26 [00:06<00:12,  1.33it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:08<00:10,  1.34it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  58%|█████▊    | 15/26 [00:11<00:08,  1.33it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  69%|██████▉   | 18/26 [00:13<00:06,  1.29it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  81%|████████  | 21/26 [00:16<00:03,  1.25it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
auc:0.7080719217712814 f1: 0.4818323384375811 recall: 0.39532242609220286 precision: 0.6168115621019991
Training:    :   3%|▎         | 3/110 [00:02<01:33,  1.15it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:05<01:31,  1.14it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:08<01:30,  1.11it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:11<01:32,  1.06it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:15<01:52,  1.19s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  15%|█▌        | 17/110 [00:18<01:57,  1.27s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  17%|█▋        | 19/110 [00:21<01:53,  1.24s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  17%|█▋        | 19/110 [14:59:36<01:53,  1.24s/it]:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  18%|█▊        | 20/110 [14:59:37<216:25:17, 8656.86s/it]UM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [14:59:43<174:08:22, 7043.84s/it]UM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  21%|██        | 23/110 [14:59:46<111:04:37, 4596.29s/it]UM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  23%|██▎       | 25/110 [14:59:49<72:31:47, 3071.86s/it] UM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [14:59:51<48:03:28, 2084.44s/it] UM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  26%|██▋       | 29/110 [14:59:55<32:09:04, 1428.94s/it] UM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  28%|██▊       | 31/110 [15:00:03<21:39:23, 986.88s/it]  UM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [15:00:11<14:39:08, 685.05s/it]  UM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  32%|███▏      | 35/110 [15:00:14<9:55:51, 476.68s/it]   UM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  34%|███▎      | 37/110 [15:00:17<6:44:32, 332.50s/it]   UM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [15:00:20<4:34:54, 232.32s/it]   UM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [15:00:23<2:40:13, 141.37s/it]   UM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [15:00:26<1:38:27, 90.88s/it]    UM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [15:00:29<1:02:23, 60.37s/it]    UM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [15:00:32<40:18, 40.99s/it]      UM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [15:00:34<26:21, 28.25s/it]      UM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [15:00:37<17:24, 19.70s/it]      UM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [15:00:40<11:34, 13.90s/it]      UM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [15:00:43<07:47,  9.95s/it]      UM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [15:00:45<05:16,  7.19s/it]      UM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [15:00:48<03:36,  5.29s/it]      UM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [15:00:51<02:30,  3.96s/it]      UM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [15:00:54<01:46,  3.05s/it]      UM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [15:00:56<01:17,  2.41s/it]      UM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [15:00:59<00:56,  1.96s/it]      UM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [15:01:03<00:45,  1.74s/it]      UM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [15:01:06<00:35,  1.53s/it]      UM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [15:01:09<00:26,  1.35s/it]      UM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [15:01:11<00:20,  1.21s/it]      UM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [15:01:14<00:15,  1.11s/it]      UM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [15:01:17<00:11,  1.04s/it]      UM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [15:01:19<00:07,  1.01it/s]     UM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [15:01:22<00:04,  1.05it/s]     UM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :   0%|          | 0/26 [00:00<?, ?it/s]:00, 491.69s/it]    UM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :  12%|█▏        | 3/26 [00:02<00:15,  1.44it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  23%|██▎       | 6/26 [00:04<00:14,  1.41it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  35%|███▍      | 9/26 [00:06<00:13,  1.31it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:08<00:10,  1.35it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  58%|█████▊    | 15/26 [00:10<00:07,  1.39it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  69%|██████▉   | 18/26 [00:13<00:05,  1.40it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  81%|████████  | 21/26 [00:15<00:03,  1.42it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:17<00:01,  1.40it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:17<00:01,  1.40it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7083953118318018 f1: 0.47506843315449465 recall: 0.38495936402030023 precision: 0.6202538883806038
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:32,  1.15it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:05<01:41,  1.03it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:08<01:39,  1.02it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:11<01:31,  1.07it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:13<01:27,  1.09it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:16<01:23,  1.11it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:19<01:20,  1.11it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:21<01:16,  1.12it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:24<01:12,  1.15it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:26<01:09,  1.15it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:29<01:06,  1.15it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:32<01:04,  1.15it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:34<01:02,  1.13it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:37<01:00,  1.13it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:40<00:58,  1.12it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:43<00:55,  1.12it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:45<00:52,  1.13it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:48<00:51,  1.08it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:52<00:55,  1.04s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  54%|█████▎    | 59/110 [00:54<00:53,  1.05s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▌    | 61/110 [00:57<00:52,  1.08s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:59<00:53,  1.14s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  59%|█████▉    | 65/110 [01:02<00:51,  1.14s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  61%|██████    | 67/110 [01:04<00:49,  1.15s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [01:06<00:47,  1.17s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▍   | 71/110 [01:09<00:45,  1.17s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  66%|██████▋   | 73/110 [01:11<00:42,  1.16s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [01:13<00:41,  1.17s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  70%|███████   | 77/110 [01:16<00:39,  1.20s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  72%|███████▏  | 79/110 [01:18<00:37,  1.21s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:20<00:33,  1.16s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  75%|███████▌  | 83/110 [01:23<00:30,  1.13s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  77%|███████▋  | 85/110 [01:25<00:27,  1.12s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:27<00:25,  1.11s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  81%|████████  | 89/110 [01:29<00:23,  1.10s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  83%|████████▎ | 91/110 [01:31<00:21,  1.11s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:33<00:18,  1.10s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  86%|████████▋ | 95/110 [01:36<00:16,  1.08s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  88%|████████▊ | 97/110 [01:38<00:14,  1.09s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:40<00:12,  1.12s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  92%|█████████▏| 101/110 [01:42<00:10,  1.11s/it]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  94%|█████████▎| 103/110 [01:44<00:07,  1.09s/it]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:47<00:05,  1.09s/it]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  97%|█████████▋| 107/110 [01:49<00:03,  1.10s/it]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  12%|█▏        | 3/26 [00:02<00:19,  1.19it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  23%|██▎       | 6/26 [00:05<00:16,  1.19it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  35%|███▍      | 9/26 [00:07<00:14,  1.19it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:10<00:11,  1.18it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  58%|█████▊    | 15/26 [00:12<00:09,  1.17it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  69%|██████▉   | 18/26 [00:15<00:06,  1.17it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  81%|████████  | 21/26 [00:17<00:04,  1.15it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:20<00:01,  1.16it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
auc:0.7087035847554761 f1: 0.47581562144668943 recall: 0.3861305319941796 precision: 0.6197664483053261
Training:    :   3%|▎         | 3/110 [00:03<01:50,  1.03s/it]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▍         | 5/110 [00:05<01:49,  1.05s/it]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   6%|▋         | 7/110 [00:07<01:47,  1.05s/it]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:09<01:46,  1.06s/it]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  10%|█         | 11/110 [00:11<01:45,  1.07s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  12%|█▏        | 13/110 [00:13<01:43,  1.07s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:15<01:41,  1.07s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  15%|█▌        | 17/110 [00:18<01:39,  1.07s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  17%|█▋        | 19/110 [00:20<01:36,  1.06s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:22<01:34,  1.06s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  21%|██        | 23/110 [00:24<01:34,  1.09s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  23%|██▎       | 25/110 [00:26<01:34,  1.11s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:29<01:31,  1.11s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  26%|██▋       | 29/110 [00:31<01:28,  1.10s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  28%|██▊       | 31/110 [00:33<01:26,  1.09s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:35<01:24,  1.09s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  32%|███▏      | 35/110 [00:37<01:21,  1.09s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  34%|███▎      | 37/110 [00:40<01:23,  1.14s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:42<01:25,  1.21s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  37%|███▋      | 41/110 [00:45<01:27,  1.27s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  39%|███▉      | 43/110 [00:49<01:33,  1.39s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:53<01:41,  1.56s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  43%|████▎     | 47/110 [00:56<01:39,  1.58s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  45%|████▍     | 49/110 [00:59<01:32,  1.52s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [01:01<01:24,  1.43s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  48%|████▊     | 53/110 [01:03<01:15,  1.33s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  50%|█████     | 55/110 [01:06<01:10,  1.29s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [01:08<01:05,  1.23s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  54%|█████▎    | 59/110 [01:10<01:03,  1.24s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▌    | 61/110 [01:12<00:57,  1.18s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [01:15<00:54,  1.15s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  59%|█████▉    | 65/110 [01:17<00:50,  1.12s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  62%|██████▏   | 68/110 [01:20<00:44,  1.07s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  64%|██████▎   | 70/110 [01:22<00:42,  1.06s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [01:24<00:40,  1.07s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  67%|██████▋   | 74/110 [01:26<00:40,  1.12s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  69%|██████▉   | 76/110 [01:29<00:38,  1.15s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [01:31<00:36,  1.15s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  73%|███████▎  | 80/110 [01:33<00:33,  1.13s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  75%|███████▍  | 82/110 [01:35<00:30,  1.11s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:37<00:27,  1.08s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  78%|███████▊  | 86/110 [01:39<00:25,  1.05s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  80%|████████  | 88/110 [01:41<00:23,  1.05s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:44<00:21,  1.07s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  84%|████████▎ | 92/110 [01:46<00:19,  1.07s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▌ | 94/110 [01:48<00:17,  1.07s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:50<00:14,  1.06s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  89%|████████▉ | 98/110 [01:52<00:12,  1.07s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  91%|█████████ | 100/110 [01:54<00:10,  1.06s/it]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:56<00:08,  1.07s/it]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▍| 104/110 [01:59<00:06,  1.12s/it]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  96%|█████████▋| 106/110 [02:01<00:04,  1.11s/it]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  98%|█████████▊| 108/110 [02:03<00:02,  1.09s/it]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  12%|█▏        | 3/26 [00:02<00:18,  1.22it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  23%|██▎       | 6/26 [00:04<00:16,  1.21it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  35%|███▍      | 9/26 [00:07<00:14,  1.19it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:10<00:12,  1.13it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  58%|█████▊    | 15/26 [00:13<00:10,  1.00it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  69%|██████▉   | 18/26 [00:17<00:08,  1.01s/it]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  81%|████████  | 21/26 [00:20<00:05,  1.02s/it]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  88%|████████▊ | 23/26 [00:22<00:03,  1.05s/it]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  96%|█████████▌| 25/26 [00:24<00:01,  1.10s/it]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  96%|█████████▌| 25/26 [00:24<00:01,  1.10s/it]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7085204081665065 f1: 0.46867101237195696 recall: 0.37509316108883134 precision: 0.6244608567208272
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   2%|▏         | 2/110 [00:02<02:07,  1.18s/it]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   4%|▎         | 4/110 [00:04<02:10,  1.23s/it]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:07<02:05,  1.20s/it]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   7%|▋         | 8/110 [00:10<02:11,  1.29s/it]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   9%|▉         | 10/110 [00:13<02:17,  1.37s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:15<02:08,  1.31s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  13%|█▎        | 14/110 [00:18<02:04,  1.30s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  15%|█▍        | 16/110 [00:20<02:00,  1.28s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:22<01:55,  1.25s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  18%|█▊        | 20/110 [00:25<01:48,  1.21s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  20%|██        | 22/110 [00:27<01:43,  1.17s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:29<01:43,  1.20s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  24%|██▎       | 26/110 [00:32<01:40,  1.20s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▌       | 28/110 [00:34<01:38,  1.20s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:36<01:34,  1.18s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  29%|██▉       | 32/110 [00:39<01:30,  1.16s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  31%|███       | 34/110 [00:41<01:26,  1.14s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:43<01:22,  1.11s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▍      | 38/110 [00:45<01:18,  1.10s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  36%|███▋      | 40/110 [00:47<01:16,  1.09s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:49<01:13,  1.08s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  40%|████      | 44/110 [00:51<01:11,  1.08s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  42%|████▏     | 46/110 [00:54<01:09,  1.09s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:56<01:08,  1.10s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  45%|████▌     | 50/110 [00:58<01:06,  1.11s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  47%|████▋     | 52/110 [01:00<01:04,  1.10s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [01:03<01:04,  1.16s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  51%|█████     | 56/110 [01:05<01:02,  1.15s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  53%|█████▎    | 58/110 [01:07<00:58,  1.12s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [01:09<00:55,  1.10s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  56%|█████▋    | 62/110 [01:12<00:52,  1.10s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  58%|█████▊    | 64/110 [01:14<00:50,  1.09s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [01:17<00:53,  1.22s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  62%|██████▏   | 68/110 [01:19<00:51,  1.23s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  64%|██████▎   | 70/110 [01:22<00:48,  1.20s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [01:24<00:46,  1.23s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  67%|██████▋   | 74/110 [01:26<00:42,  1.19s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  69%|██████▉   | 76/110 [01:29<00:39,  1.16s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [01:31<00:36,  1.14s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  73%|███████▎  | 80/110 [01:33<00:33,  1.13s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  75%|███████▍  | 82/110 [01:35<00:32,  1.17s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:38<00:30,  1.18s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  78%|███████▊  | 86/110 [01:41<00:31,  1.30s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  80%|████████  | 88/110 [01:44<00:28,  1.30s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:46<00:24,  1.23s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  84%|████████▎ | 92/110 [01:48<00:21,  1.17s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▌ | 94/110 [01:50<00:19,  1.22s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:53<00:16,  1.21s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  89%|████████▉ | 98/110 [01:55<00:14,  1.18s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  91%|█████████ | 100/110 [01:58<00:11,  1.19s/it]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [02:00<00:09,  1.24s/it]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▍| 104/110 [02:02<00:07,  1.19s/it]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  96%|█████████▋| 106/110 [02:05<00:04,  1.17s/it]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  98%|█████████▊| 108/110 [02:07<00:02,  1.19s/it]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :   8%|▊         | 2/26 [00:02<00:25,  1.06s/it]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:04<00:24,  1.09s/it]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  27%|██▋       | 7/26 [00:07<00:18,  1.02it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  38%|███▊      | 10/26 [00:10<00:15,  1.01it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  50%|█████     | 13/26 [00:13<00:13,  1.03s/it]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  58%|█████▊    | 15/26 [00:15<00:11,  1.08s/it]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  69%|██████▉   | 18/26 [00:18<00:07,  1.00it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  81%|████████  | 21/26 [00:20<00:04,  1.11it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:22<00:01,  1.17it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:22<00:01,  1.17it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.709224047675966 f1: 0.4753652437151758 recall: 0.3845334847570714 precision: 0.6223792291343558
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   2%|▏         | 2/110 [00:02<01:59,  1.11s/it]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   4%|▎         | 4/110 [00:04<01:55,  1.09s/it]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:06<01:49,  1.05s/it]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   7%|▋         | 8/110 [00:08<01:46,  1.04s/it]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   9%|▉         | 10/110 [00:10<01:43,  1.04s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:12<01:41,  1.03s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  13%|█▎        | 14/110 [00:14<01:38,  1.03s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  15%|█▌        | 17/110 [00:17<01:32,  1.01it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  18%|█▊        | 20/110 [00:21<01:40,  1.12s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  20%|██        | 22/110 [00:23<01:35,  1.09s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  23%|██▎       | 25/110 [00:26<01:27,  1.03s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▌       | 28/110 [00:28<01:21,  1.00it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  28%|██▊       | 31/110 [00:31<01:16,  1.03it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  31%|███       | 34/110 [00:34<01:12,  1.05it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  34%|███▎      | 37/110 [00:37<01:12,  1.01it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  36%|███▋      | 40/110 [00:40<01:08,  1.02it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  39%|███▉      | 43/110 [00:43<01:07,  1.01s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:46<01:07,  1.05s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  43%|████▎     | 47/110 [00:48<01:06,  1.06s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  45%|████▌     | 50/110 [00:51<01:01,  1.02s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  48%|████▊     | 53/110 [00:53<00:55,  1.02it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  51%|█████     | 56/110 [00:56<00:51,  1.04it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  54%|█████▎    | 59/110 [00:59<00:48,  1.06it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  56%|█████▋    | 62/110 [01:02<00:46,  1.03it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  59%|█████▉    | 65/110 [01:05<00:43,  1.05it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  62%|██████▏   | 68/110 [01:07<00:39,  1.06it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▍   | 71/110 [01:10<00:35,  1.09it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  67%|██████▋   | 74/110 [01:13<00:32,  1.10it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  70%|███████   | 77/110 [01:15<00:29,  1.11it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  73%|███████▎  | 80/110 [01:18<00:26,  1.13it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  75%|███████▌  | 83/110 [01:21<00:24,  1.11it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  78%|███████▊  | 86/110 [01:24<00:22,  1.08it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  81%|████████  | 89/110 [01:26<00:19,  1.10it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  84%|████████▎ | 92/110 [01:29<00:16,  1.07it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  86%|████████▋ | 95/110 [01:32<00:14,  1.03it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  89%|████████▉ | 98/110 [01:36<00:12,  1.00s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  92%|█████████▏| 101/110 [01:38<00:08,  1.02it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▍| 104/110 [01:41<00:05,  1.05it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  97%|█████████▋| 107/110 [01:44<00:02,  1.07it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :   0%|          | 0/26 [00:00<?, ?it/s],  1.04it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :  12%|█▏        | 3/26 [00:02<00:15,  1.46it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  23%|██▎       | 6/26 [00:04<00:13,  1.45it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  35%|███▍      | 9/26 [00:06<00:11,  1.45it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:08<00:09,  1.43it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  58%|█████▊    | 15/26 [00:10<00:07,  1.44it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  69%|██████▉   | 18/26 [00:12<00:05,  1.46it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  81%|████████  | 21/26 [00:14<00:03,  1.43it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
auc:0.7091138214648463 f1: 0.46993712919507663 recall: 0.3766902083259396 precision: 0.6245366284201236
Training:    :   3%|▎         | 3/110 [00:02<01:33,  1.15it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:05<01:30,  1.15it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:07<01:29,  1.13it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:10<01:25,  1.15it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:13<01:23,  1.13it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:15<01:21,  1.13it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:18<01:19,  1.12it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:21<01:16,  1.13it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:23<01:13,  1.13it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:26<01:11,  1.12it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:29<01:10,  1.10it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:32<01:07,  1.10it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:34<01:04,  1.10it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:37<01:02,  1.09it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:40<00:58,  1.10it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:43<00:56,  1.09it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:45<00:53,  1.10it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:48<00:49,  1.13it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:50<00:47,  1.12it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:53<00:44,  1.13it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:56<00:41,  1.14it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:58<00:38,  1.13it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [01:01<00:36,  1.13it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [01:04<00:33,  1.13it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [01:06<00:30,  1.14it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [01:09<00:28,  1.14it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:12<00:25,  1.14it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:14<00:22,  1.13it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:17<00:20,  1.13it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:20<00:17,  1.12it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:22<00:15,  1.13it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:25<00:12,  1.14it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:27<00:09,  1.15it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:30<00:06,  1.15it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:33<00:04,  1.15it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :   0%|          | 0/26 [00:00<?, ?it/s],  1.14it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :  12%|█▏        | 3/26 [00:02<00:17,  1.32it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  23%|██▎       | 6/26 [00:04<00:14,  1.35it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  35%|███▍      | 9/26 [00:06<00:12,  1.32it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:08<00:10,  1.35it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  58%|█████▊    | 15/26 [00:11<00:08,  1.36it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  69%|██████▉   | 18/26 [00:13<00:05,  1.36it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  81%|████████  | 21/26 [00:15<00:03,  1.40it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:17<00:01,  1.39it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:17<00:01,  1.39it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:45,  1.01it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:05<01:39,  1.05it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:08<01:32,  1.10it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:11<01:28,  1.10it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:13<01:25,  1.11it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:16<01:23,  1.10it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:19<01:20,  1.11it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:21<01:17,  1.12it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:24<01:14,  1.12it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:27<01:10,  1.13it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:29<01:09,  1.10it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:32<01:08,  1.09it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:35<01:07,  1.05it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:38<01:04,  1.05it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:41<01:00,  1.07it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:44<00:57,  1.09it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:46<00:54,  1.09it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:49<00:51,  1.08it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:52<00:49,  1.07it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:55<00:45,  1.09it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:57<00:42,  1.11it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [01:00<00:39,  1.12it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [01:02<00:36,  1.13it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [01:05<00:34,  1.11it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [01:08<00:31,  1.10it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [01:11<00:29,  1.09it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:14<00:27,  1.06it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:17<00:24,  1.08it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:19<00:21,  1.09it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:22<00:18,  1.10it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:25<00:15,  1.09it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:28<00:12,  1.08it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:30<00:10,  1.07it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:33<00:07,  1.07it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:36<00:04,  1.06it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  98%|█████████▊| 108/110 [01:39<00:01,  1.05it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  12%|█▏        | 3/26 [00:02<00:16,  1.38it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  23%|██▎       | 6/26 [00:04<00:14,  1.41it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  35%|███▍      | 9/26 [00:06<00:12,  1.39it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:08<00:10,  1.38it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  58%|█████▊    | 15/26 [00:11<00:08,  1.32it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  69%|██████▉   | 18/26 [00:13<00:06,  1.25it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  81%|████████  | 21/26 [00:16<00:04,  1.25it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
auc:0.7097856037375372 f1: 0.48063330506078605 recall: 0.3921638215565887 precision: 0.6206470456077287
Training:    :   3%|▎         | 3/110 [00:02<01:34,  1.13it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:05<01:34,  1.11it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:08<01:31,  1.11it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:10<01:29,  1.09it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:13<01:26,  1.09it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:16<01:23,  1.10it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:19<01:26,  1.03it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:22<01:25,  1.00it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:26<01:25,  1.03s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  26%|██▋       | 29/110 [00:28<01:25,  1.06s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  29%|██▉       | 32/110 [00:31<01:18,  1.01s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  32%|███▏      | 35/110 [00:34<01:14,  1.01it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▍      | 38/110 [00:37<01:13,  1.02s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  36%|███▋      | 40/110 [00:39<01:12,  1.04s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:41<01:13,  1.08s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  40%|████      | 44/110 [00:44<01:11,  1.08s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  42%|████▏     | 46/110 [00:46<01:10,  1.10s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:48<01:08,  1.11s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:51<01:02,  1.06s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  48%|████▊     | 53/110 [00:53<00:59,  1.05s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  51%|█████     | 56/110 [00:56<00:55,  1.02s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  53%|█████▎    | 58/110 [00:58<00:54,  1.06s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▌    | 61/110 [01:01<00:49,  1.00s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  58%|█████▊    | 64/110 [01:04<00:45,  1.02it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  61%|██████    | 67/110 [01:07<00:44,  1.04s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [01:10<00:45,  1.12s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▍   | 71/110 [01:13<00:45,  1.17s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  66%|██████▋   | 73/110 [01:15<00:43,  1.18s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [01:18<00:41,  1.19s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  70%|███████   | 77/110 [01:20<00:39,  1.19s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  72%|███████▏  | 79/110 [01:22<00:35,  1.14s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:24<00:32,  1.13s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  75%|███████▌  | 83/110 [01:27<00:32,  1.21s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  77%|███████▋  | 85/110 [01:29<00:29,  1.18s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:33<00:30,  1.33s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  81%|████████  | 89/110 [01:35<00:27,  1.30s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  84%|████████▎ | 92/110 [01:39<00:22,  1.24s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▌ | 94/110 [01:44<00:25,  1.60s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:47<00:22,  1.61s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  89%|████████▉ | 98/110 [01:49<00:18,  1.51s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  91%|█████████ | 100/110 [01:53<00:15,  1.59s/it]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:55<00:11,  1.46s/it]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▍| 104/110 [01:58<00:08,  1.44s/it]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  96%|█████████▋| 106/110 [02:01<00:05,  1.42s/it]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  98%|█████████▊| 108/110 [02:05<00:03,  1.54s/it]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  12%|█▏        | 3/26 [00:02<00:19,  1.20it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  23%|██▎       | 6/26 [00:04<00:15,  1.30it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  35%|███▍      | 9/26 [00:06<00:12,  1.33it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:09<00:10,  1.35it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  58%|█████▊    | 15/26 [00:11<00:08,  1.37it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  69%|██████▉   | 18/26 [00:13<00:05,  1.38it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  81%|████████  | 21/26 [00:15<00:03,  1.39it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:18<00:00,  1.39it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:18<00:00,  1.39it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7100337201502458 f1: 0.48564902602999477 recall: 0.39993611811051566 precision: 0.6181229773462783
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:37,  1.10it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:05<01:38,  1.06it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:08<01:34,  1.07it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:11<01:29,  1.09it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:13<01:25,  1.11it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:16<01:22,  1.11it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:19<01:20,  1.11it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:21<01:17,  1.11it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:24<01:15,  1.10it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:27<01:12,  1.11it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:29<01:08,  1.13it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:32<01:06,  1.12it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:35<01:06,  1.06it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:38<01:04,  1.06it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:41<00:59,  1.08it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:43<00:55,  1.11it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:46<00:53,  1.11it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:48<00:49,  1.13it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:51<00:46,  1.13it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:54<00:43,  1.14it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:56<00:41,  1.14it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:59<00:38,  1.14it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [01:02<00:35,  1.14it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [01:04<00:33,  1.14it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [01:07<00:31,  1.11it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [01:10<00:28,  1.12it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:12<00:25,  1.14it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:15<00:22,  1.14it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:17<00:20,  1.15it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:20<00:17,  1.14it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:23<00:14,  1.14it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:26<00:12,  1.12it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:28<00:09,  1.12it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:31<00:07,  1.11it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:34<00:04,  1.07it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :   0%|          | 0/26 [00:00<?, ?it/s],  1.12it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  12%|█▏        | 3/26 [00:02<00:20,  1.13it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  23%|██▎       | 6/26 [00:04<00:16,  1.24it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  35%|███▍      | 9/26 [00:07<00:13,  1.25it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:09<00:10,  1.28it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  58%|█████▊    | 15/26 [00:11<00:08,  1.31it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  69%|██████▉   | 18/26 [00:14<00:06,  1.22it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  81%|████████  | 21/26 [00:17<00:04,  1.16it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:19<00:01,  1.18it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:19<00:01,  1.18it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7100132483189673 f1: 0.4703015264638766 recall: 0.3766902083259396 precision: 0.6258254716981132
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   2%|▏         | 2/110 [00:02<01:58,  1.10s/it]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   4%|▎         | 4/110 [00:04<01:55,  1.09s/it]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:06<01:50,  1.06s/it]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   7%|▋         | 8/110 [00:08<01:56,  1.14s/it]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   9%|▉         | 10/110 [00:11<02:03,  1.23s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:14<02:01,  1.24s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  13%|█▎        | 14/110 [00:16<01:58,  1.23s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  15%|█▍        | 16/110 [00:18<01:51,  1.19s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  17%|█▋        | 19/110 [00:21<01:40,  1.10s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:24<01:40,  1.12s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  21%|██        | 23/110 [00:26<01:42,  1.17s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  23%|██▎       | 25/110 [00:29<01:45,  1.24s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:31<01:40,  1.21s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  26%|██▋       | 29/110 [00:34<01:37,  1.20s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  28%|██▊       | 31/110 [00:36<01:34,  1.20s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:38<01:29,  1.16s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:41<01:19,  1.08s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:44<01:15,  1.07s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  37%|███▋      | 41/110 [00:47<01:15,  1.10s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  40%|████      | 44/110 [00:49<01:07,  1.02s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  43%|████▎     | 47/110 [00:52<00:59,  1.06it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  45%|████▌     | 50/110 [00:54<00:53,  1.13it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  48%|████▊     | 53/110 [00:56<00:48,  1.17it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  51%|█████     | 56/110 [00:59<00:46,  1.16it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  54%|█████▎    | 59/110 [01:03<00:49,  1.03it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  56%|█████▋    | 62/110 [01:05<00:44,  1.07it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  59%|█████▉    | 65/110 [01:07<00:39,  1.13it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  62%|██████▏   | 68/110 [01:10<00:35,  1.18it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▍   | 71/110 [01:12<00:31,  1.23it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  67%|██████▋   | 74/110 [01:14<00:28,  1.26it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  70%|███████   | 77/110 [01:16<00:25,  1.28it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  73%|███████▎  | 80/110 [01:19<00:23,  1.26it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  75%|███████▌  | 83/110 [01:21<00:20,  1.29it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  78%|███████▊  | 86/110 [01:23<00:18,  1.30it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  81%|████████  | 89/110 [01:26<00:16,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  84%|████████▎ | 92/110 [01:28<00:13,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  86%|████████▋ | 95/110 [01:30<00:11,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  89%|████████▉ | 98/110 [01:32<00:09,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  92%|█████████▏| 101/110 [01:35<00:06,  1.32it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▍| 104/110 [01:37<00:04,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  97%|█████████▋| 107/110 [01:39<00:02,  1.33it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:13,  1.63it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:05<00:11,  1.54it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:09,  1.55it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:10<00:06,  1.55it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:12<00:03,  1.61it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:16<00:00,  1.62it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:16<00:00,  1.62it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7106039706301757 f1: 0.48270181219110375 recall: 0.39514497639919083 precision: 0.6201058201058202
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:20,  1.33it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:18,  1.32it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:18,  1.28it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:09<01:18,  1.25it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:14,  1.28it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:10,  1.30it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:16<01:08,  1.30it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:18<01:05,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:03,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:23<01:01,  1.29it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:25<00:58,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:27<00:56,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:53,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:32<00:51,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:34<00:48,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:36<00:46,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:44,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:41<00:42,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:43<00:39,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:45<00:37,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:47<00:35,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:50<00:32,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:52<00:30,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:54<00:28,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:56<00:26,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:59<00:24,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:01<00:22,  1.29it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:04<00:21,  1.23it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:07<00:21,  1.09it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:11<00:21,  1.05s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:14<00:17,  1.03s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:17<00:14,  1.00s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:20<00:10,  1.03it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:23<00:07,  1.01it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:26<00:05,  1.01s/it]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  98%|█████████▊| 108/110 [01:29<00:02,  1.04s/it]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:13,  1.66it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.65it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.64it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:06,  1.64it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:12<00:03,  1.65it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:15<00:00,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:15<00:00,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7108660913121181 f1: 0.4867681574470834 recall: 0.40114277602299747 precision: 0.618867717915024
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:21,  1.32it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:18,  1.33it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:15,  1.34it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:09<01:14,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:12,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:11,  1.29it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:16<01:08,  1.30it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:18<01:04,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:03,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<01:01,  1.30it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:25<00:59,  1.30it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:27<00:56,  1.30it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:54,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:32<00:51,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:34<00:49,  1.30it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:36<00:47,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:39<00:45,  1.30it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:41<00:42,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:43<00:40,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:45<00:38,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:48<00:35,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:50<00:33,  1.30it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:52<00:31,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:55<00:29,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:57<00:26,  1.30it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [01:00<00:25,  1.24it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:03<00:25,  1.15it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:05<00:23,  1.12it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:08<00:20,  1.10it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:11<00:17,  1.14it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:13<00:14,  1.18it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:15<00:11,  1.20it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:18<00:08,  1.24it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:20<00:06,  1.25it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:22<00:03,  1.25it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:13,  1.66it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.69it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:09,  1.46it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  58%|█████▊    | 15/26 [00:10<00:07,  1.43it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  69%|██████▉   | 18/26 [00:12<00:05,  1.42it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  81%|████████  | 21/26 [00:14<00:03,  1.44it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  96%|█████████▌| 25/26 [00:16<00:00,  1.49it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  96%|█████████▌| 25/26 [00:16<00:00,  1.49it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.710987597172672 f1: 0.48253251405866654 recall: 0.3943641977499379 precision: 0.6214765100671141
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:18,  1.36it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:18,  1.32it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:16,  1.32it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:09<01:21,  1.20it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:12<01:24,  1.13it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:15<01:23,  1.11it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:18<01:19,  1.12it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:20<01:17,  1.12it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:23<01:16,  1.09it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:26<01:15,  1.06it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:29<01:11,  1.08it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:31<01:06,  1.12it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:34<01:02,  1.13it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:37<01:00,  1.12it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:39<00:57,  1.12it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:42<00:56,  1.10it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:45<00:53,  1.10it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:47<00:49,  1.14it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:50<00:44,  1.18it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:52<00:41,  1.21it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:55<00:40,  1.17it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:58<00:39,  1.13it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [01:00<00:36,  1.12it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [01:03<00:34,  1.10it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [01:06<00:31,  1.11it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [01:08<00:28,  1.13it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:11<00:26,  1.10it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:14<00:23,  1.08it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:17<00:20,  1.10it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:19<00:17,  1.14it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:22<00:14,  1.13it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:25<00:12,  1.11it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:27<00:10,  1.09it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:31<00:07,  1.05it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:33<00:04,  1.08it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :   0%|          | 0/26 [00:00<?, ?it/s],  1.13it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :  12%|█▏        | 3/26 [00:02<00:15,  1.49it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  23%|██▎       | 6/26 [00:04<00:13,  1.47it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  35%|███▍      | 9/26 [00:06<00:12,  1.40it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:08<00:09,  1.41it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  58%|█████▊    | 15/26 [00:10<00:07,  1.44it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  73%|███████▎  | 19/26 [00:13<00:04,  1.47it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  88%|████████▊ | 23/26 [00:15<00:02,  1.47it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
auc:0.7107587799322197 f1: 0.481063903882988 recall: 0.3921993114951911 precision: 0.6219958349749536
Training:    :   3%|▎         | 3/110 [00:02<01:38,  1.09it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:05<01:31,  1.14it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:07<01:24,  1.20it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:10<01:23,  1.17it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:12<01:22,  1.15it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:15<01:17,  1.18it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:17<01:15,  1.18it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:20<01:10,  1.22it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:22<01:09,  1.20it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:26<01:13,  1.09it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:29<01:12,  1.06it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:31<01:09,  1.06it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:35<01:08,  1.04it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:37<01:03,  1.08it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:39<00:57,  1.13it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:42<00:52,  1.18it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:44<00:51,  1.15it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:47<00:49,  1.13it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:50<00:46,  1.13it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:53<00:46,  1.08it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:56<00:42,  1.10it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:58<00:39,  1.11it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [01:01<00:36,  1.12it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [01:03<00:32,  1.17it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [01:05<00:29,  1.20it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [01:08<00:26,  1.23it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:10<00:23,  1.24it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:12<00:20,  1.26it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:15<00:17,  1.28it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:17<00:15,  1.30it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:19<00:12,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:21<00:10,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:24<00:08,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:26<00:06,  1.32it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:28<00:03,  1.31it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:13,  1.65it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.68it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.69it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.68it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.68it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.68it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.68it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:20,  1.33it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:18,  1.32it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:16,  1.32it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:09<01:13,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:05,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:03,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:02,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<01:01,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:59,  1.29it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:27<00:56,  1.30it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:53,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:51,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:49,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:36<00:46,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:44,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:43,  1.29it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:43<00:41,  1.28it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:45<00:39,  1.27it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:48<00:37,  1.26it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:50<00:35,  1.25it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:52<00:32,  1.26it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:55<00:31,  1.19it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:58<00:30,  1.15it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [01:01<00:28,  1.13it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:04<00:26,  1.09it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:07<00:24,  1.08it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:09<00:21,  1.09it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:12<00:17,  1.14it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:14<00:14,  1.17it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:17<00:11,  1.19it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:19<00:09,  1.20it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:21<00:06,  1.22it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:24<00:04,  1.22it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  12%|█▏        | 3/26 [00:02<00:15,  1.50it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  23%|██▎       | 6/26 [00:04<00:13,  1.45it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  35%|███▍      | 9/26 [00:06<00:12,  1.37it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:08<00:10,  1.35it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  58%|█████▊    | 15/26 [00:11<00:08,  1.32it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  69%|██████▉   | 18/26 [00:13<00:05,  1.33it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  81%|████████  | 21/26 [00:15<00:03,  1.38it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Training:    :   0%|          | 0/110 [00:00<?, ?it/s]43it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Training:    :   0%|          | 0/110 [00:00<?, ?it/s]43it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7110534398466972 f1: 0.48420870468114563 recall: 0.3972033928381304 precision: 0.6200210514652927
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:39,  1.07it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:05<01:36,  1.08it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:07<01:26,  1.17it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:10<01:19,  1.24it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:12<01:16,  1.25it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:14<01:12,  1.26it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:17<01:09,  1.28it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:19<01:06,  1.29it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:21<01:03,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:23<01:00,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:26<00:58,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:28<00:56,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:30<00:53,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:32<00:51,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:35<00:49,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:37<00:46,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:39<00:44,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:41<00:42,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:44<00:39,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:46<00:37,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:48<00:35,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:50<00:32,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:53<00:30,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:55<00:28,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:57<00:26,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:59<00:23,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:02<00:21,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:04<00:19,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:06<00:17,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:08<00:15,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:11<00:12,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:13<00:10,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:15<00:08,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:17<00:06,  1.32it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:20<00:03,  1.33it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  98%|█████████▊| 108/110 [01:22<00:01,  1.32it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.69it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.69it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.72it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:15<00:00,  1.72it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:15<00:00,  1.72it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7107675520794108 f1: 0.4728544858737047 recall: 0.3789615643964936 precision: 0.6285983399069877
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:28,  1.21it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:05<01:26,  1.20it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:07<01:22,  1.22it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:09<01:21,  1.21it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:12<01:19,  1.20it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:14<01:15,  1.21it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:17<01:13,  1.22it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:19<01:11,  1.21it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:22<01:12,  1.15it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:25<01:07,  1.18it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:27<01:04,  1.20it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:30<01:02,  1.18it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:32<00:58,  1.21it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:35<00:56,  1.21it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:37<00:53,  1.21it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:39<00:50,  1.23it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:42<00:49,  1.20it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:45<00:47,  1.17it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:47<00:43,  1.22it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:49<00:40,  1.24it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:51<00:37,  1.27it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:54<00:34,  1.29it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:56<00:31,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:58<00:28,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [01:00<00:26,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [01:03<00:24,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:05<00:21,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:07<00:19,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:09<00:17,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:12<00:15,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:14<00:12,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:16<00:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:18<00:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:21<00:05,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:23<00:03,  1.33it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :   0%|          | 0/26 [00:00<?, ?it/s],  1.27it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:13,  1.67it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.70it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.69it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7114299908232518 f1: 0.4877796901893287 recall: 0.40231394399687687 precision: 0.6193520187947331
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:19,  1.34it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:15,  1.37it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:15,  1.34it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:13,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:06,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:03,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:01,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:57,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:55,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:53,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:51,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:44,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:42,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:47<00:35,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:33,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:56<00:26,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:23,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:05<00:17,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:14,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:05,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  98%|█████████▊| 108/110 [01:20<00:01,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:13,  1.68it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.70it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7109756613125165 f1: 0.4794723969252271 recall: 0.38960854597721545 precision: 0.6232188475730911
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:18,  1.37it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:19,  1.31it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:16,  1.32it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:09<01:13,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:11,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:09,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:06,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:18<01:04,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:02,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:56,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:54,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:52,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:44,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:42,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:47<00:35,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:33,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:56<00:26,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:23,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:05<00:17,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:14,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:14<00:08,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:06,  1.33it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.33it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  98%|█████████▊| 108/110 [01:21<00:01,  1.32it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.72it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:11,  1.62it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:09,  1.55it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:06,  1.61it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:12<00:03,  1.55it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:12<00:03,  1.55it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7110278670607812 f1: 0.47981454752219743 recall: 0.3893246264683962 precision: 0.6251068436947974
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:18,  1.36it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:17,  1.34it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:15,  1.34it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:13,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:11,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:06,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:04,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:01,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:57,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:55,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:53,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:44,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:47<00:35,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:33,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:31,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:56<00:26,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:23,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:05<00:17,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:15,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:14<00:08,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:05,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.32it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  98%|█████████▊| 108/110 [01:20<00:01,  1.32it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.70it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.69it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.68it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.69it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.68it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
auc:0.7116344195213959 f1: 0.4848222217407319 recall: 0.39706143308372077 precision: 0.6223854027592345
Training:    :   3%|▎         | 3/110 [00:02<01:21,  1.32it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:17,  1.34it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:15,  1.33it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:13,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:06,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:04,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:02,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<01:00,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:58,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:27<00:55,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:52,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:44,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:47<00:35,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:33,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:56<00:26,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:24,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:03<00:19,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:05<00:17,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:15,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:12<00:10,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:14<00:08,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:06,  1.33it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.33it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.71it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.73it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.69it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.69it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7116814200537525 f1: 0.48785425101214575 recall: 0.4019945345494552 precision: 0.6203516074264747
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:17,  1.38it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:15,  1.39it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:13,  1.37it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:12,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:11,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:09,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:07,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:18<01:05,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:02,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<01:01,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:58,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:27<00:55,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:53,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:45,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:43,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:47<00:35,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:33,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:56<00:26,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:24,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:05<00:17,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:15,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:14<00:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:05,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.33it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.71it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.71it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.72it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.69it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.69it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7118734128860779 f1: 0.487323882883466 recall: 0.4007878766369734 precision: 0.6215189873417721
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:18,  1.36it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:18,  1.33it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:15,  1.34it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:12,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:06,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:03,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:02,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:57,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:55,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:52,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:43,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:47<00:35,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:33,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:56<00:26,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:24,  1.30it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:22,  1.30it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:03<00:19,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:05<00:17,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:14,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:14<00:08,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:05,  1.36it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.36it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :   0%|          | 0/26 [00:00<?, ?it/s],  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.70it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.74it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:06<00:08,  1.73it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.73it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:18,  1.36it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:18,  1.33it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:15,  1.33it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:13,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:11,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:06,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:04,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:02,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:57,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:55,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:52,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:43,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:47<00:35,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:33,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:55<00:25,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:23,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:05<00:17,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:15,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:06,  1.33it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :   0%|          | 0/26 [00:00<?, ?it/s],  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:13,  1.68it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.73it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.72it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
auc:0.7118978772887372 f1: 0.4944830230477569 recall: 0.41193171735812895 precision: 0.618413341147637
Training:    :   3%|▎         | 3/110 [00:02<01:17,  1.38it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:17,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:14,  1.36it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:12,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:06,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:03,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:01,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:56,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:53,  1.38it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:28<00:52,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:47,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:37<00:44,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:46<00:35,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:32,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:55<00:25,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:23,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:04<00:16,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:06<00:14,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:15<00:05,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :   0%|          | 0/26 [00:00<?, ?it/s],  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.74it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.75it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.67it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.67it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
auc:0.7120592531823482 f1: 0.4830349753909143 recall: 0.39358341910068495 precision: 0.6251056873907896
Training:    :   3%|▎         | 3/110 [00:02<01:17,  1.38it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:17,  1.34it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:15,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:13,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:07,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:05,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:03,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:01,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:56,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:55,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:28<00:52,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:45,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:37<00:43,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:46<00:34,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:48<00:32,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:55<00:26,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:23,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:04<00:17,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:14,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:15<00:05,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :   0%|          | 0/26 [00:00<?, ?it/s],  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:13,  1.67it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.72it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.72it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.72it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7121304647512655 f1: 0.48200606708714344 recall: 0.3919153919863719 precision: 0.6258784856041714
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:19,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:17,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:15,  1.33it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:13,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:07,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:06,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:04,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:02,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:57,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:55,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:52,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:37<00:43,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:36,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:46<00:34,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:32,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:55<00:25,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:57<00:23,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:04<00:17,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:06<00:14,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:06,  1.31it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.29it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :   0%|          | 0/26 [00:00<?, ?it/s],  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:13,  1.67it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.70it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:06<00:08,  1.73it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.73it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.73it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7122112074445806 f1: 0.484561601598124 recall: 0.3959967349256486 precision: 0.6241539408178106
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:19,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:18,  1.33it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:16,  1.33it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:13,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:05,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:03,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:01,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:56,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:54,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:28<00:52,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:37<00:44,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:42,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:40,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:38,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:47<00:35,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:32,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:55<00:25,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:24,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:22,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:03<00:21,  1.20it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:06<00:19,  1.17it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:09<00:17,  1.15it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:11<00:14,  1.16it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:14<00:12,  1.16it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:16<00:09,  1.14it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:19<00:07,  1.14it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:22<00:04,  1.14it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  98%|█████████▊| 108/110 [01:24<00:01,  1.14it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  12%|█▏        | 3/26 [00:02<00:16,  1.41it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  23%|██▎       | 6/26 [00:04<00:13,  1.45it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  38%|███▊      | 10/26 [00:06<00:10,  1.57it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  54%|█████▍    | 14/26 [00:08<00:07,  1.63it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  69%|██████▉   | 18/26 [00:11<00:04,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  85%|████████▍ | 22/26 [00:13<00:02,  1.65it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:15<00:00,  1.67it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:15<00:00,  1.67it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7121000488611664 f1: 0.47780247837474965 recall: 0.3852077935905171 precision: 0.6289986091794159
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:21,  1.32it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:17,  1.34it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:15,  1.34it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:13,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:06,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:03,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:01,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:58,  1.37it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:56,  1.37it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:54,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:28<00:52,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:37<00:44,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:46<00:34,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:48<00:32,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:55<00:26,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:24,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:22,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:04<00:17,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:15,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:06,  1.33it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.33it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.70it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.72it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.72it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Training:    :   0%|          | 0/110 [00:00<?, ?it/s]75it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Training:    :   0%|          | 0/110 [00:00<?, ?it/s]75it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7119670723923632 f1: 0.47816526672237125 recall: 0.3858821024239628 precision: 0.6284607826137217
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:19,  1.34it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:17,  1.34it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:15,  1.34it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:12,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:06,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:03,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:03,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<01:00,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:58,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:27<00:56,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:53,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:51,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:36<00:46,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:44,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:47<00:35,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:32,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:54<00:28,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:56<00:26,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:23,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:05<00:17,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:14,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:05,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.36it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.70it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.71it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:06<00:08,  1.72it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.73it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:14<00:00,  1.75it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:14<00:00,  1.75it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7121733785407711 f1: 0.4978130876666596 recall: 0.41807147673634526 precision: 0.6151436031331593
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:17,  1.39it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:17,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:15,  1.34it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:13,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:11,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:06,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:03,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:01,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:57,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:54,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:28<00:52,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:37<00:43,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:46<00:35,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:32,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:55<00:26,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:24,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:04<00:17,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:15,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:05,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.73it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.69it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:14<00:00,  1.74it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:14<00:00,  1.74it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.71236873165032 f1: 0.4941211553207805 recall: 0.4116477978493097 precision: 0.6179212615204305
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:22,  1.30it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:17,  1.34it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:18,  1.29it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:09<01:15,  1.30it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:12,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:06,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:18<01:04,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:01,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:57,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:55,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:52,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:44,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:47<00:35,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:32,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:56<00:26,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:23,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:04<00:16,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:15,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:14<00:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:05,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.33it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.70it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.72it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:06<00:08,  1.72it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:14<00:00,  1.75it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:14<00:00,  1.75it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7124126002338987 f1: 0.47913053024481284 recall: 0.38723072009085424 precision: 0.6282243205895901
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:20,  1.33it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:17,  1.34it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:15,  1.33it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:09<01:13,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:09,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:06,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:18<01:04,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:02,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:58,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:55,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:53,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:51,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:43,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:36,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:47<00:34,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:32,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:55<00:25,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:23,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:04<00:17,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:14,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:15<00:05,  1.36it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.36it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:13,  1.64it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.69it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.69it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:10<00:06,  1.47it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:13<00:04,  1.44it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:16<00:00,  1.55it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:16<00:00,  1.55it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7124763651564379 f1: 0.4955037309466612 recall: 0.4135997444724421 precision: 0.6178560067861308
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:21,  1.31it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:20,  1.29it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:18,  1.29it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:09<01:15,  1.29it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:15,  1.26it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:14<01:12,  1.28it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:16<01:09,  1.29it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:18<01:05,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:03,  1.30it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:23<01:02,  1.29it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:25<00:59,  1.29it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:27<00:56,  1.30it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:30<00:55,  1.28it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:32<00:53,  1.27it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:35<00:53,  1.21it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:37<00:51,  1.20it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:41<00:52,  1.12it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:43<00:50,  1.10it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:46<00:45,  1.15it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:48<00:42,  1.17it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:51<00:41,  1.14it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:54<00:41,  1.06it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:57<00:37,  1.09it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:59<00:33,  1.12it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [01:02<00:30,  1.16it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [01:04<00:27,  1.17it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:07<00:24,  1.18it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:09<00:21,  1.21it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:13<00:21,  1.09it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:16<00:18,  1.06it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:19<00:16,  1.03it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:21<00:13,  1.06it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:24<00:09,  1.11it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:26<00:06,  1.15it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:28<00:04,  1.20it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:13,  1.68it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.68it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.68it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.68it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.68it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.66it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
auc:0.712473207796311 f1: 0.49680826246474247 recall: 0.41569365084998405 precision: 0.6172533726812817
Training:    :   3%|▎         | 3/110 [00:02<01:19,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:19,  1.30it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:16,  1.32it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:09<01:15,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:11,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:09,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:06,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:18<01:04,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:01,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:56,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:54,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:52,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:44,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:47<00:35,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:32,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:56<00:26,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:24,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:22,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:03<00:20,  1.29it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:05<00:18,  1.22it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:08<00:16,  1.22it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:10<00:13,  1.25it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:12<00:11,  1.27it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:15<00:08,  1.30it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:17<00:06,  1.31it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:19<00:03,  1.31it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:13,  1.68it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.72it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.72it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.73it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.73it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:13<00:01,  1.73it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:13<00:01,  1.73it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.712531453224345 f1: 0.4917962650009627 recall: 0.4079568442346595 precision: 0.61900915455035
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:16,  1.40it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:16,  1.37it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:15,  1.34it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:12,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:05,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:04,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:02,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<01:00,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:57,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:55,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:53,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:51,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:44,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:47<00:35,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:32,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:55<00:25,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:23,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:04<00:17,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:14,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:05,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.75it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.69it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.69it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:14<00:00,  1.74it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
auc:0.7126605324143264 f1: 0.4915359694479607 recall: 0.40653724669056324 precision: 0.6214735243055556
Training:    :   3%|▎         | 3/110 [00:02<01:17,  1.38it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:16,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:14,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:11,  1.37it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:07,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:05,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:03,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:19<01:00,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:56,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:54,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:28<00:52,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:30<00:50,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:45,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:37<00:43,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:39<00:41,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:46<00:35,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:48<00:33,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:31,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:55<00:26,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:24,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:04<00:17,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:06<00:14,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:15<00:05,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:13,  1.69it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.73it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.72it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.73it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.73it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7127049959224314 f1: 0.4855325707091537 recall: 0.39691947332931116 precision: 0.6250838363514419
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:23,  1.28it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:18,  1.33it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:15,  1.33it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:12,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:09,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:07,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:18<01:04,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:02,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:57,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:27<00:55,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:52,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:45,  1.37it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:43,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:40,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:45<00:38,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:47<00:34,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:33,  1.30it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:54<00:28,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:56<00:26,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:24,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:22,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:03<00:19,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:05<00:17,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:15,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:12<00:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:14<00:08,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:05,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.33it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :   0%|          | 0/26 [00:00<?, ?it/s],  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.71it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.71it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.72it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:13<00:01,  1.72it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:13<00:01,  1.72it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7126253997293968 f1: 0.4843566424437579 recall: 0.39503850658338363 precision: 0.6258644925499016
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:16,  1.39it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:16,  1.36it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:15,  1.34it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:12,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:06,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:04,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:02,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:57,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:56,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:53,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:51,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:36<00:46,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:44,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:42,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:43<00:41,  1.28it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:45<00:38,  1.29it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:47<00:36,  1.30it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:33,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:54<00:28,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:56<00:25,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:23,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:03<00:19,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:05<00:17,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:14,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:14<00:08,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:05,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :   0%|          | 0/26 [00:00<?, ?it/s],  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.73it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.70it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.74it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.68it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.68it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7126286508872975 f1: 0.495504113258083 recall: 0.4136352344110445 precision: 0.6177780133573625
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:18,  1.36it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:18,  1.32it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:16,  1.32it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:09<01:13,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:06,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:04,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:01,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<01:00,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:57,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:55,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:53,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:44,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:46<00:34,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:32,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:56<00:26,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:24,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:04<00:17,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:14,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:05,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :   0%|          | 0/26 [00:00<?, ?it/s],  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.70it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.73it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.72it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7126386237207343 f1: 0.4894222069024947 recall: 0.40313021258473225 precision: 0.6227180527383367
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:20,  1.33it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:17,  1.34it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:16,  1.33it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:12,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:07,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:04,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:02,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<01:00,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:59,  1.30it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:27<00:56,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:53,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:51,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:36<00:47,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:44,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:42,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:43<00:40,  1.30it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:45<00:38,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:47<00:35,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:33,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:52<00:30,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:54<00:28,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:56<00:25,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:23,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:01<00:22,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:03<00:19,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:05<00:17,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:14,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:12<00:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:14<00:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:06,  1.33it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  98%|█████████▊| 108/110 [01:21<00:01,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:13,  1.69it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.72it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
auc:0.7128078804958362 f1: 0.48381824125531225 recall: 0.393938318486709 precision: 0.6268353286650101
Training:    :   3%|▎         | 3/110 [00:02<01:18,  1.36it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:17,  1.34it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:14,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:11,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:06,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:04,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:02,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<01:00,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:57,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:55,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:53,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:45,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:37<00:43,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:36,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:46<00:34,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:33,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:31,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:55<00:25,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:23,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:22,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:04<00:17,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:14,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:05,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  98%|█████████▊| 108/110 [01:20<00:01,  1.33it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.70it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.71it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Training:    :   0%|          | 0/110 [00:00<?, ?it/s]74it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Training:    :   0%|          | 0/110 [00:00<?, ?it/s]74it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7127402661276032 f1: 0.4957072424345461 recall: 0.4139191539198637 precision: 0.6177763652735844
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:19,  1.34it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:17,  1.34it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:14,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:09<01:14,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:11,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:06,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:04,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:01,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:57,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:54,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:52,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:49,  1.37it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:47,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:37<00:43,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:42,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:40,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:47<00:35,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:33,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:56<00:26,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:23,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:04<00:17,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:14,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:14<00:08,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:05,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.33it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  98%|█████████▊| 108/110 [01:20<00:01,  1.33it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:13,  1.68it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.71it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.68it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.712879112991747 f1: 0.48414371726041694 recall: 0.395251446214998 precision: 0.6246214245653393
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:19,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:18,  1.33it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:14,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:13,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:09,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:06,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:18<01:05,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:02,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<01:00,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:58,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:27<00:55,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:52,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:51,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:36<00:46,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:43,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:36,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:47<00:34,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:32,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:55<00:25,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:23,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:04<00:17,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:14,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:05,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.36it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:13,  1.66it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.67it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.68it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Training:    :   0%|          | 0/110 [00:00<?, ?it/s]73it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Training:    :   0%|          | 0/110 [00:00<?, ?it/s]73it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7128529882563804 f1: 0.4890699780106067 recall: 0.40256237356709373 precision: 0.6229337140974244
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:18,  1.36it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:17,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:13,  1.37it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:11,  1.37it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:10<01:09,  1.37it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:07,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:05,  1.37it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:03,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:19<01:00,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:56,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:54,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:28<00:52,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:30<00:50,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:37<00:43,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:39<00:41,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:46<00:34,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:48<00:32,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:55<00:26,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:57<00:24,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:04<00:17,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:06<00:14,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:15<00:06,  1.33it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  98%|█████████▊| 108/110 [01:20<00:01,  1.33it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.71it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.71it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.72it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:14<00:00,  1.74it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:14<00:00,  1.74it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7125717003169794 f1: 0.47674059702808763 recall: 0.383717216169216 precision: 0.6292998079273616
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:18,  1.36it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:16,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:15,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:12,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:11,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:09,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:06,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:04,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:02,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<01:00,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:58,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:27<00:56,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:53,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:45,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:44,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:47<00:34,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:32,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:55<00:26,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:23,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:04<00:16,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:14,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:05,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.33it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  98%|█████████▊| 108/110 [01:20<00:01,  1.33it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:13,  1.67it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.71it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.72it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.73it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.73it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:14<00:00,  1.76it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:14<00:00,  1.76it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:19,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:16,  1.36it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:15,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:12,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:06,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:03,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:01,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:57,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:54,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:28<00:52,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:47,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:37<00:43,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:46<00:35,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:32,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:55<00:26,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:24,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:04<00:17,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:14,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:06,  1.32it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.32it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  98%|█████████▊| 108/110 [01:20<00:01,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.74it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.73it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:06<00:08,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:14<00:00,  1.74it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:14<00:00,  1.74it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7127471978204656 f1: 0.4930125219026454 recall: 0.4094119317173581 precision: 0.6195156006659148
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:17,  1.39it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:17,  1.34it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:15,  1.34it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:12,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:06,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:04,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:01,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:57,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:55,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:53,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:37<00:43,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:46<00:35,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:32,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:55<00:26,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:24,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:04<00:17,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:14,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:05,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  98%|█████████▊| 108/110 [01:20<00:01,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.73it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.71it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.69it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.69it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:14<00:00,  1.73it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:14<00:00,  1.73it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7130017560101737 f1: 0.4844177858912505 recall: 0.3955353657238173 precision: 0.6248248023770814
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:19,  1.34it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:17,  1.34it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:15,  1.33it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:13,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:06,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:03,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:01,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:57,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:55,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:54,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:51,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:49,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:44,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:47<00:35,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:32,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:56<00:26,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:23,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:04<00:17,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:14,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:05,  1.36it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  98%|█████████▊| 108/110 [01:20<00:01,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.71it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.74it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.68it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.69it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7127926792773203 f1: 0.4985079049292049 recall: 0.417965006920538 precision: 0.6175020973154363
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:15,  1.41it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:15,  1.37it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:14,  1.36it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:12,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:07,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:05,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:04,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:19<01:01,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:58,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:56,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:54,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:28<00:52,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:37<00:44,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:42,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:46<00:35,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:48<00:32,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:55<00:26,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:24,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:04<00:17,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:06<00:14,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:15<00:05,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  98%|█████████▊| 108/110 [01:20<00:01,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.72it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.68it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.69it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:14<00:00,  1.74it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:14<00:00,  1.74it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7130000661554579 f1: 0.4953941070098925 recall: 0.4132093551478156 precision: 0.6183875079668578
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:17,  1.38it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:16,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:13,  1.37it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:14,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:11,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:07,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:07,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:04,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:02,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<01:00,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:57,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:55,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:52,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:43,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:40,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:45<00:40,  1.24it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:48<00:38,  1.21it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:50<00:35,  1.23it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:52<00:32,  1.26it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:54<00:29,  1.29it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:57<00:26,  1.30it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:59<00:24,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:01<00:21,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:03<00:19,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:06<00:17,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:08<00:15,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:10<00:12,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:12<00:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:15<00:08,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:17<00:05,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:19<00:03,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :   0%|          | 0/26 [00:00<?, ?it/s],  1.33it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.70it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.72it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.72it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
auc:0.7131332892638257 f1: 0.48813280878474774 recall: 0.4007168967597686 precision: 0.6243295548797346
Training:    :   3%|▎         | 3/110 [00:02<01:18,  1.36it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:17,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:14,  1.36it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:13,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:06,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:03,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:01,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:57,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:55,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:28<00:52,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:45,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:40,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:47<00:35,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:33,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:55<00:26,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:23,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:05<00:17,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:15,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:05,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  98%|█████████▊| 108/110 [01:20<00:01,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:13,  1.67it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.72it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.68it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.69it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.68it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
auc:0.7131187379031935 f1: 0.48767514270887397 recall: 0.40022003761933495 precision: 0.6240385147473854
Training:    :   3%|▎         | 3/110 [00:02<01:19,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:17,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:14,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:13,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:07,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:05,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:03,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:19<01:01,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:57,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:55,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:53,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:51,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:49,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:36<00:48,  1.29it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:49,  1.19it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:42<00:50,  1.11it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:44<00:47,  1.11it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:47<00:44,  1.13it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:49<00:39,  1.18it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:51<00:36,  1.22it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:54<00:33,  1.22it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:56<00:30,  1.25it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:58<00:27,  1.28it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [01:01<00:24,  1.28it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:03<00:22,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:05<00:19,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:07<00:17,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:10<00:15,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:12<00:12,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:14<00:10,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:16<00:08,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:18<00:05,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:21<00:03,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.76it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.71it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:06<00:08,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.69it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.68it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.68it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7130855753452126 f1: 0.49396225608583216 recall: 0.41012173048940626 precision: 0.620889748549323
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:16,  1.40it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:16,  1.36it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:14,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:13,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:07,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:04,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:03,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<01:00,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:57,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:55,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:53,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:45,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:43,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:47<00:35,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:32,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:56<00:26,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:23,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:04<00:17,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:15,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:05,  1.33it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:13,  1.68it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.72it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.69it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.69it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7131364085069289 f1: 0.48992508395763373 recall: 0.4038400113567803 precision: 0.6226538987688098
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:19,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:16,  1.36it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:15,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:13,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:11,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:09,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:06,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:04,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:02,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:57,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:54,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:52,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:44,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:47<00:35,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:33,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:55<00:25,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:23,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:04<00:17,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:14,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:05,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.36it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :   0%|          | 0/26 [00:00<?, ?it/s],  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.69it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.69it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.72it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7132020602221395 f1: 0.4940176053328775 recall: 0.4102991801824183 precision: 0.6206581843560423
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:20,  1.33it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:17,  1.34it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:17,  1.30it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:09<01:14,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:11,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:09,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:07,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:18<01:04,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:02,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:57,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:27<00:55,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:53,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:36<00:46,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:44,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:42,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:45<00:37,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:47<00:35,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:32,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:56<00:26,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:23,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:05<00:17,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:14,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:14<00:08,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:05,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.36it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :   0%|          | 0/26 [00:00<?, ?it/s],  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:14,  1.56it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:11,  1.63it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.68it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.69it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7132119086147048 f1: 0.49246058944482524 recall: 0.40799233417326186 precision: 0.6210361406731133
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:17,  1.38it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:16,  1.36it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:14,  1.36it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:09<01:14,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:11,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:09,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:06,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:03,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:01,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:57,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:55,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:53,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:52,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:44,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:42,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:47<00:34,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:32,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:56<00:26,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:23,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:04<00:17,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:14,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:05,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  98%|█████████▊| 108/110 [01:20<00:01,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:13,  1.64it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.70it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.68it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.69it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
auc:0.7132478619367322 f1: 0.49093138836894074 recall: 0.4049047095148525 precision: 0.6233744945907551
Training:    :   3%|▎         | 3/110 [00:02<01:18,  1.36it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:17,  1.34it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:16,  1.32it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:13,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:11,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:06,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:04,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:01,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:56,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:54,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:28<00:51,  1.37it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:37<00:44,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:46<00:35,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:32,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:55<00:26,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:23,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:04<00:17,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:14,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:06,  1.33it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  98%|█████████▊| 108/110 [01:20<00:01,  1.36it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.72it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.72it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:06<00:08,  1.72it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
auc:0.7129790012681347 f1: 0.4960071361821426 recall: 0.4144160130602974 precision: 0.6176019463690696
Training:    :   3%|▎         | 3/110 [00:02<01:17,  1.38it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:16,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:13,  1.37it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:11,  1.37it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:11,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:07,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:04,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:01,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:56,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:54,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:28<00:52,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:47,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:45,  1.37it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:37<00:43,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:39<00:41,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:46<00:35,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:48<00:32,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:55<00:26,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:57<00:23,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:04<00:17,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:06<00:14,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:15<00:05,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:17<00:03,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :   0%|          | 0/26 [00:00<?, ?it/s],  1.36it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.75it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.72it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:06<00:08,  1.72it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.72it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:13<00:01,  1.72it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
auc:0.7131418121555779 f1: 0.4908439063137331 recall: 0.4057209781027079 precision: 0.6211693110193436
Training:    :   3%|▎         | 3/110 [00:02<01:19,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:15,  1.37it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:13,  1.38it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:12,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:05,  1.37it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:03,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:19<01:02,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:57,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:54,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:28<00:52,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:47,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:45,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:37<00:43,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:46<00:35,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:48<00:32,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:55<00:26,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:57<00:23,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:04<00:17,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:06<00:14,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:15<00:05,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.70it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.73it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:06<00:08,  1.72it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.72it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:14<00:00,  1.74it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:14<00:00,  1.74it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7132552454284338 f1: 0.4892350174742201 recall: 0.4024204138126841 precision: 0.623810309732079
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:15,  1.42it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:18,  1.33it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:16,  1.32it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:13,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:06,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:05,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:02,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<01:00,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:58,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:27<00:55,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:53,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:43,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:36,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:47<00:34,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:32,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:55<00:25,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:23,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:05<00:17,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:15,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:05,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.72it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.73it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:06<00:08,  1.73it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.72it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.73it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:14<00:00,  1.76it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:14<00:00,  1.76it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7131986412745953 f1: 0.48840376094239707 recall: 0.40096532632998544 precision: 0.6246130030959752
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:17,  1.38it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:17,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:14,  1.36it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:11,  1.37it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:05,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:03,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:01,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<01:00,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:57,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:55,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:53,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:37<00:43,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:46<00:34,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:32,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:27,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:55<00:26,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:57<00:23,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:04<00:17,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:15,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:15<00:05,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:13,  1.67it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.71it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.67it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:14<00:00,  1.74it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:14<00:00,  1.74it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.713086328343278 f1: 0.49925027982513565 recall: 0.41949107428044147 precision: 0.6164597892980077
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:20,  1.34it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:17,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:17,  1.30it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:09<01:14,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:11,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:09,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:06,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:03,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:01,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:57,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:55,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:52,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:51,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:44,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:47<00:34,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:32,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:56<00:26,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:23,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:05<00:17,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:14,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:05,  1.36it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.70it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.72it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:14<00:00,  1.73it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:14<00:00,  1.73it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.713288078386269 f1: 0.4941297234875216 recall: 0.41001526067359906 precision: 0.621663796814464
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:17,  1.38it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:16,  1.37it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:15,  1.34it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:13,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:11,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:09,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:07,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:04,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:02,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:57,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:55,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:53,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:43,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:36,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:46<00:34,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:34,  1.28it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:52<00:34,  1.20it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:55<00:32,  1.18it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:57<00:30,  1.16it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [01:00<00:27,  1.16it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:02<00:24,  1.16it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:05<00:22,  1.15it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:08<00:20,  1.14it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:10<00:17,  1.15it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:13<00:14,  1.15it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:15<00:11,  1.17it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:18<00:09,  1.22it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:20<00:06,  1.24it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:22<00:03,  1.28it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.71it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.72it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:06<00:08,  1.72it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.72it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:14<00:00,  1.75it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:14<00:00,  1.75it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7133246610128832 f1: 0.4900032282363069 recall: 0.40401746104979236 precision: 0.6224846894138233
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:17,  1.37it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:17,  1.33it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:14,  1.36it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:13,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:06,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:03,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:01,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:57,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:55,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:53,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:49,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:44,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:42,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:46<00:35,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:32,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:56<00:26,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:23,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:04<00:16,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:14,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:05,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.32it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.69it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.72it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.69it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.69it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:14<00:00,  1.74it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:14<00:00,  1.74it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7133244894862767 f1: 0.49036868045541615 recall: 0.40430138055861164 precision: 0.6229902657770973
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:21,  1.32it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:17,  1.34it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:16,  1.33it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:13,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:05,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:04,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:01,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:56,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:54,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:28<00:51,  1.37it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:37<00:43,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:36,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:46<00:35,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:32,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:55<00:26,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:24,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:04<00:17,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:15,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:05,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.71it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.69it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.68it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.68it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.69it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.68it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.68it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:19,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:18,  1.32it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:15,  1.34it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:13,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:11,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:07,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:04,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:02,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<01:00,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:57,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:54,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:52,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:43,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:47<00:35,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:32,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:55<00:26,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:23,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:04<00:16,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:14,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:05,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.73it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.72it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:06<00:08,  1.72it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.72it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
auc:0.7133281845953943 f1: 0.4841765948641997 recall: 0.3944706675657451 precision: 0.6266914749661705
Training:    :   3%|▎         | 3/110 [00:02<01:21,  1.32it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:16,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:13,  1.37it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:12,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:06,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:03,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:02,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:57,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:55,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:52,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:44,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:42,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:40,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:38,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:47<00:35,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:33,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:56<00:26,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:23,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:05<00:17,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:14,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:05,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.69it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.72it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.72it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
auc:0.7133340348111342 f1: 0.4903356195308637 recall: 0.40469176988323813 precision: 0.6219592014835824
Training:    :   3%|▎         | 3/110 [00:02<01:21,  1.32it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:16,  1.36it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:16,  1.31it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:13,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:05,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:04,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:01,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:57,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:55,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:28<00:52,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:37<00:43,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:46<00:35,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:32,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:55<00:25,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:57<00:23,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:04<00:17,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:15,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:06,  1.33it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.33it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.72it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.70it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:06<00:08,  1.73it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.72it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
auc:0.7133221815378634 f1: 0.4942957671393538 recall: 0.41132838840188807 precision: 0.6191900844107276
Training:    :   3%|▎         | 3/110 [00:02<01:17,  1.38it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:16,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:14,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:12,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:06,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:04,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:19<01:01,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:57,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:55,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:53,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:51,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:49,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:37<00:43,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:41,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:46<00:34,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:32,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:55<00:25,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:23,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:04<00:17,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:06<00:14,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:15<00:05,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.76it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.72it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:06<00:08,  1.74it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:06,  1.65it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.67it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.66it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.66it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7135520787606529 f1: 0.4916659506830483 recall: 0.40618234730453917 precision: 0.6227215844169977
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:20,  1.33it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:16,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:14,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:12,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:09,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:06,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:03,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:01,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:57,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:55,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:53,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:51,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:49,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:45,  1.30it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:42,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:40,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:45<00:37,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:47<00:35,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:33,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:31,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:54<00:29,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:56<00:26,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:23,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:03<00:19,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:05<00:17,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:14,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:12<00:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:14<00:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:05,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.33it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  98%|█████████▊| 108/110 [01:21<00:01,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.70it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.73it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.69it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:06,  1.67it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.66it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
auc:0.7134656954952281 f1: 0.49481765834932817 recall: 0.41171877772651455 precision: 0.6199433548869769
Training:    :   3%|▎         | 3/110 [00:02<01:24,  1.27it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:22,  1.26it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:07<01:23,  1.20it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:10<01:27,  1.12it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:12<01:22,  1.15it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:15<01:18,  1.18it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:17<01:12,  1.22it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:19<01:08,  1.25it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:21<01:04,  1.29it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:24<01:01,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:26<00:58,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:28<00:55,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:30<00:53,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:33<00:50,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:35<00:48,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:37<00:46,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:39<00:44,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:42<00:41,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:44<00:39,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:46<00:37,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:48<00:35,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:50<00:32,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:53<00:30,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:55<00:28,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:57<00:26,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:59<00:23,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:02<00:21,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:04<00:19,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:06<00:17,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:08<00:14,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:11<00:12,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:13<00:10,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:15<00:08,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:17<00:06,  1.33it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:20<00:03,  1.33it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  98%|█████████▊| 108/110 [01:22<00:01,  1.34it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.72it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.71it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:17,  1.38it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:16,  1.36it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:14,  1.36it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:11,  1.37it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:06,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:04,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:19<01:01,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:57,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:55,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:28<00:52,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:50,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:46,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:44,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:42,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:46<00:34,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:32,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:55<00:26,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:23,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:02<00:19,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:04<00:17,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:14,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:13<00:08,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:15<00:05,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:18<00:03,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  98%|█████████▊| 108/110 [01:20<00:01,  1.35it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.71it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.71it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.71it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.68it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.68it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7132582574206959 f1: 0.500822125721995 recall: 0.42158498065798344 precision: 0.6167384870982815
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:19,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:17,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:14,  1.35it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:13,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:14,  1.28it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:14<01:17,  1.19it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:16<01:14,  1.20it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:19<01:11,  1.21it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:21<01:07,  1.23it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:23<01:04,  1.24it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:26<01:04,  1.20it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:29<01:01,  1.21it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:31<00:57,  1.24it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:33<00:53,  1.26it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:35<00:50,  1.28it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:38<00:47,  1.30it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:40<00:45,  1.29it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:42<00:42,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:45<00:40,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:47<00:37,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:49<00:35,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:51<00:33,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:54<00:30,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:56<00:29,  1.30it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:58<00:26,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [01:00<00:24,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:03<00:22,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:05<00:19,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:07<00:17,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:10<00:15,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:12<00:12,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:14<00:10,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:16<00:08,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:19<00:06,  1.33it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:21<00:03,  1.32it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:13,  1.66it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.68it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.68it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.70it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.713514002469886 f1: 0.49565809637323355 recall: 0.413244845086418 precision: 0.6191311745626629
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:16,  1.39it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:16,  1.36it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:15,  1.34it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:08<01:12,  1.36it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:10,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.35it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:06,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:17<01:04,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:02,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<00:59,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:24<00:57,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:26<00:55,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:53,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:31<00:51,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:33<00:48,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:35<00:47,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:44,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:40<00:42,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:42<00:39,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:44<00:37,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:47<00:35,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:49<00:32,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:51<00:30,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:53<00:28,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:56<00:26,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:58<00:24,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:00<00:21,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:03<00:19,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:05<00:17,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:07<00:14,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:09<00:12,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:11<00:10,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:14<00:08,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:16<00:06,  1.31it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:19<00:04,  1.23it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  12%|█▏        | 3/26 [00:02<00:15,  1.50it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  27%|██▋       | 7/26 [00:04<00:12,  1.57it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  42%|████▏     | 11/26 [00:06<00:09,  1.59it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  58%|█████▊    | 15/26 [00:09<00:06,  1.62it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  73%|███████▎  | 19/26 [00:11<00:04,  1.64it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  88%|████████▊ | 23/26 [00:14<00:01,  1.63it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  88%|████████▊ | 23/26 [00:14<00:01,  1.63it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:26,  1.24it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:05<01:28,  1.18it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:07<01:25,  1.18it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:10<01:27,  1.12it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:13<01:25,  1.11it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:15<01:22,  1.12it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:18<01:22,  1.08it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:21<01:20,  1.06it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:24<01:20,  1.03it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:27<01:18,  1.01it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:31<01:17,  1.01s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  32%|███▏      | 35/110 [00:33<01:17,  1.03s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  34%|███▎      | 37/110 [00:35<01:17,  1.06s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:37<01:16,  1.07s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  37%|███▋      | 41/110 [00:40<01:15,  1.10s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  39%|███▉      | 43/110 [00:42<01:13,  1.09s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:44<01:11,  1.10s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:47<01:04,  1.05s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:50<00:59,  1.01s/it]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:52<00:51,  1.08it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:54<00:46,  1.14it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:57<00:43,  1.16it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [01:00<00:43,  1.09it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [01:02<00:38,  1.14it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [01:05<00:38,  1.08it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [01:08<00:35,  1.08it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [01:11<00:31,  1.09it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [01:13<00:28,  1.12it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:16<00:24,  1.16it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:18<00:22,  1.15it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:21<00:19,  1.17it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:24<00:17,  1.16it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:26<00:14,  1.19it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:29<00:12,  1.17it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:31<00:09,  1.19it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:33<00:06,  1.21it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:36<00:04,  1.21it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  98%|█████████▊| 108/110 [01:38<00:01,  1.24it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:14,  1.56it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:11,  1.64it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.60it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:10<00:06,  1.58it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:12<00:03,  1.59it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Training:    :   0%|          | 0/110 [00:00<?, ?it/s]64it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Training:    :   0%|          | 0/110 [00:00<?, ?it/s]64it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.7135670254919816 f1: 0.48832033191434193 recall: 0.40100081626858786 precision: 0.6242541436464089
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:24,  1.27it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:21,  1.28it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:07<01:18,  1.28it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:09<01:14,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:13,  1.30it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:14<01:11,  1.28it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:16<01:10,  1.27it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:18<01:06,  1.29it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:21<01:04,  1.28it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:23<01:01,  1.30it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:25<00:59,  1.29it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:27<00:56,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:30<00:53,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:32<00:51,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:34<00:48,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:36<00:46,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:39<00:44,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:41<00:42,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:43<00:40,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:45<00:37,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:48<00:35,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:50<00:33,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:52<00:30,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:54<00:28,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:57<00:26,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [00:59<00:24,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:01<00:21,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:03<00:19,  1.34it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:06<00:17,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:08<00:15,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:10<00:12,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:13<00:10,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:15<00:08,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:17<00:06,  1.31it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:19<00:03,  1.31it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  98%|█████████▊| 108/110 [01:22<00:01,  1.30it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:13,  1.57it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.65it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.67it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.67it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:12<00:03,  1.65it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:15<00:00,  1.69it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:15<00:00,  1.69it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
auc:0.713305369314553 f1: 0.4964905956445218 recall: 0.4154807112183696 precision: 0.6167421767990728
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:21,  1.31it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:23,  1.25it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:07<01:20,  1.25it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:09<01:17,  1.27it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:14,  1.27it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:14<01:12,  1.27it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:16<01:09,  1.27it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:18<01:07,  1.27it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:21<01:04,  1.28it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:23<01:02,  1.29it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:25<00:59,  1.30it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:27<00:56,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:30<00:54,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:32<00:51,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:34<00:49,  1.30it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:37<00:47,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:39<00:45,  1.30it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:41<00:43,  1.30it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:44<00:40,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:46<00:38,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:48<00:35,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:50<00:33,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:53<00:31,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:55<00:28,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:57<00:26,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [01:00<00:24,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:02<00:22,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:04<00:19,  1.30it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:06<00:17,  1.30it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:09<00:15,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:11<00:13,  1.29it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:13<00:10,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:16<00:08,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:18<00:06,  1.30it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:20<00:03,  1.32it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :   0%|          | 0/26 [00:00<?, ?it/s],  1.31it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :  15%|█▌        | 4/26 [00:02<00:12,  1.71it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.68it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.69it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:05,  1.69it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:11<00:03,  1.69it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  92%|█████████▏| 24/26 [00:14<00:01,  1.68it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
auc:0.713362101646226 f1: 0.4978308255560493 recall: 0.4174326578415019 precision: 0.6165862864332146
Training:    :   3%|▎         | 3/110 [00:02<01:20,  1.33it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:18,  1.33it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:06<01:16,  1.32it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:09<01:14,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:11,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:13<01:08,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:15<01:06,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:18<01:05,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:03,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:22<01:01,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:25<01:00,  1.28it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:27<00:57,  1.28it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:55,  1.28it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:32<00:53,  1.27it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:34<00:50,  1.28it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:36<00:48,  1.28it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:39<00:46,  1.28it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:41<00:43,  1.29it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:43<00:41,  1.29it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:46<00:39,  1.28it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:48<00:36,  1.27it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:51<00:34,  1.26it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:53<00:31,  1.28it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:55<00:29,  1.28it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:58<00:27,  1.27it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [01:00<00:25,  1.25it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:03<00:23,  1.24it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:05<00:20,  1.25it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:07<00:18,  1.26it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:10<00:15,  1.28it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:12<00:13,  1.28it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:14<00:10,  1.30it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:16<00:08,  1.29it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:19<00:06,  1.29it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:21<00:03,  1.29it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:14,  1.55it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:05<00:11,  1.61it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.58it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:10<00:06,  1.51it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:13<00:03,  1.51it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
auc:0.7135003816130668 f1: 0.4926983855081153 recall: 0.4083117436206835 precision: 0.6210526315789474
Training:    :   3%|▎         | 3/110 [00:02<01:25,  1.25it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:24,  1.23it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:07<01:25,  1.18it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:10<01:24,  1.16it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:12<01:22,  1.16it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:15<01:18,  1.17it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:17<01:14,  1.20it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:20<01:12,  1.19it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:22<01:08,  1.21it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:25<01:06,  1.21it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:27<01:06,  1.16it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:30<01:04,  1.16it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:33<01:01,  1.16it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:35<01:00,  1.13it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:38<00:57,  1.12it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:41<00:56,  1.09it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:44<00:52,  1.11it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:46<00:49,  1.14it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:49<00:45,  1.16it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:51<00:42,  1.17it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:54<00:41,  1.14it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:57<00:39,  1.12it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:59<00:35,  1.14it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [01:02<00:32,  1.16it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [01:04<00:30,  1.17it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [01:07<00:27,  1.18it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:09<00:24,  1.20it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:11<00:21,  1.23it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:14<00:18,  1.25it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:16<00:15,  1.26it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:18<00:13,  1.28it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:21<00:11,  1.23it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:24<00:09,  1.21it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:26<00:06,  1.22it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:28<00:04,  1.23it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Testing:    :   0%|          | 0/26 [00:00<?, ?it/s],  1.19it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:13,  1.69it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.67it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.65it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:06,  1.62it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:12<00:03,  1.60it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:12<00:03,  1.60it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   3%|▎         | 3/110 [00:02<01:21,  1.31it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   5%|▌         | 6/110 [00:04<01:20,  1.30it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :   8%|▊         | 9/110 [00:07<01:19,  1.27it/s]nt][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  11%|█         | 12/110 [00:09<01:17,  1.27it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  14%|█▎        | 15/110 [00:11<01:15,  1.26it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  16%|█▋        | 18/110 [00:14<01:11,  1.28it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  19%|█▉        | 21/110 [00:16<01:08,  1.29it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  22%|██▏       | 24/110 [00:18<01:05,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  25%|██▍       | 27/110 [00:20<01:02,  1.33it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  27%|██▋       | 30/110 [00:23<01:00,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  30%|███       | 33/110 [00:25<00:58,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  33%|███▎      | 36/110 [00:27<00:56,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  35%|███▌      | 39/110 [00:29<00:53,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  38%|███▊      | 42/110 [00:32<00:51,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  41%|████      | 45/110 [00:34<00:49,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  44%|████▎     | 48/110 [00:36<00:46,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  46%|████▋     | 51/110 [00:38<00:44,  1.32it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  49%|████▉     | 54/110 [00:41<00:42,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  52%|█████▏    | 57/110 [00:43<00:40,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  55%|█████▍    | 60/110 [00:45<00:38,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  57%|█████▋    | 63/110 [00:48<00:35,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  60%|██████    | 66/110 [00:50<00:33,  1.31it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  63%|██████▎   | 69/110 [00:53<00:33,  1.24it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  65%|██████▌   | 72/110 [00:55<00:31,  1.22it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  68%|██████▊   | 75/110 [00:58<00:28,  1.24it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  71%|███████   | 78/110 [01:00<00:25,  1.25it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  74%|███████▎  | 81/110 [01:02<00:22,  1.27it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  76%|███████▋  | 84/110 [01:05<00:20,  1.25it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  79%|███████▉  | 87/110 [01:07<00:18,  1.24it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  82%|████████▏ | 90/110 [01:10<00:16,  1.24it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  85%|████████▍ | 93/110 [01:12<00:13,  1.24it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  87%|████████▋ | 96/110 [01:14<00:11,  1.26it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  90%|█████████ | 99/110 [01:17<00:08,  1.25it/s]t][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  93%|█████████▎| 102/110 [01:19<00:06,  1.27it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  95%|█████████▌| 105/110 [01:21<00:03,  1.28it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
Training:    :  98%|█████████▊| 108/110 [01:24<00:01,  1.28it/s]][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]eprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  a = (((batch[student][:, 0:C.NUM_OF_QUESTIONS] - batch[student][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  15%|█▌        | 4/26 [00:02<00:13,  1.68it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  31%|███       | 8/26 [00:04<00:10,  1.64it/s]dent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  46%|████▌     | 12/26 [00:07<00:08,  1.65it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  62%|██████▏   | 16/26 [00:09<00:06,  1.64it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:12<00:03,  1.66it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    :  77%|███████▋  | 20/26 [00:12<00:03,  1.66it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:15<00:00,  1.69it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).
Testing:    : 100%|██████████| 26/26 [00:15<00:00,  1.69it/s]ent][:, C.NUM_OF_QUESTIONS:]).sum(1) + 1)//2)[1:]recated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').).